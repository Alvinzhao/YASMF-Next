<!DOCTYPE html>

<html>
<head>
  <title>h.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="core.html">
                core.js
              </a>
            
              
              <a class="source" href="datetime.html">
                datetime.js
              </a>
            
              
              <a class="source" href="device.html">
                device.js
              </a>
            
              
              <a class="source" href="fileManager.html">
                fileManager.js
              </a>
            
              
              <a class="source" href="filename.html">
                filename.js
              </a>
            
              
              <a class="source" href="h.html">
                h.js
              </a>
            
              
              <a class="source" href="misc.html">
                misc.js
              </a>
            
              
              <a class="source" href="object.html">
                object.js
              </a>
            
              
              <a class="source" href="router.html">
                router.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>h.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-comment">/**
 *
 * # h - simple DOM templating
 *
 * @module h.js
 * @author Kerri Shotts
 * @version 0.1
 *
 * ```
 * Copyright (c) 2014 Kerri Shotts, photoKandy Studios LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this
 * software and associated documentation files (the "Software"), to deal in the Software
 * without restriction, including without limitation the rights to use, copy, modify,
 * merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following
 * conditions:
 * The above copyright notice and this permission notice shall be included in all copies
 * or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
 * PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
 * OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 * ```
 *
 * Generates a DOM tree (or just a single node) based on a series of method calls
 * into **h**. **h** has one root method (`el`) that creates all DOM elements, but also has
 * helper methods for each HTML tag. This means that a UL can be created simply by
 * calling `h.ul`.
 *
 * Technically there's no such thing as a template using this library, but functions
 * encapsulating a series of h calls function as an equivalent if properly decoupled
 * from their surrounds.
 *
 * Templates are essentially methods attached to the DOM using `h.renderTo(templateFn(context,...))`
 * and return DOM node elements or arrays. For example:
 *
 * ```
 * function aTemplate ( context ) {
 *   return h.div (
 *     [ h.span ( context.title ), h.span ( context.description ) ]
 *   );
 * };
 * ```
 *
 * The resulting DOM tree looks like this (assuming `context` is defined as
 * `{title: "Title", description: "Description"}`:
 *
 * ```
 * &lt;div&gt;
 *   &lt;span&gt;Title&lt;/span&gt;
 *   &lt;span&gt;Description&lt;/span&gt;
 * &lt;/div&gt;
 * ```
 *
 * Template results are added to the DOM using `h.renderTo`:
 *
 * ```
 * h.renderTo ( aDOMElement, aTemplate ( context ) );
 * ```
 *
 * Technically `appendChild` could be used, but it's possible that an attribute
 * might just return an array of DOM nodes, in which case `appendChild` fails.
 *
 * There are also a variety of utility methods defined in **h**, such as:
 * - `forEach ( arr, fn )` -- this executes `arr.map(fn)`.
 * - `forIn ( object, fn )` -- iterates over each property owned by `object` and calls `fn`
 * - `ifdef ( expr, a, b )` -- determines if `expr` is defined, and if so, returns `a`, otherwise `b`
 * - `iif ( expr, a, b )` -- returns `a` if `expr` evaluates to true, otherwise `b`
 *
 * When constructing Node elements using `h`, it's important to recognize that an underlying
 * function called `el` is being called (and can be called directly). The order parameters here is
 * somewhat malleable - only the first parameter must be the tag name (when using `el`). Otherwise,
 * the options for the tag must be within the first three parameters. The text content or value content
 * for the tag must be in the same first three parameters. For example:
 *
 * ```
 * return h.el("div", { attrs: { id: "anElement" } }, "Text content");
 * ```
 *
 * is equivalent to:
 *
 * ```
 * return h.el("div", "Text Content", { attrs: { id: "anElement" } } );
 * ```
 *
 * which is also in turn equivalent to:
 *
 * ```
 * return h.div("Text Content", { attrs: { id: "anElement" } } );
 * ```
 *
 * If an object has both text and value content (like buttons), the first string or number is used
 * as the `value` and the second is used as `textContent`:
 *
 * ```
 * return h.button("This goes into value attribute", "This is in textContent");
 * ```
 *
 * So why `el` and `h.div` equivalents? If you need to specify a custom tag OR want to use shorthand
 * you'll want to use `el`. If you don't need to specify shorthand properties, use the easier-to-read
 * `h.tagName`. For example:
 *
 * ```
 * return h.p ( "paragraph content" );
 * return h.el ( "p", "paragraph content" );
 *
 * return h.el ( "input#txtUsername.bigField?type=text&amp;size=20", "starting value" );
 * return h.input ( { attrs: { type: "text", size: "20", class: "bigField", id: "txtUserName" } },
 *                  "starting value" );
 * ```
 *
 * When specifying tag options, you have several options that can be specified:
 * * attributes using `attrs` object
 * * styles using `styles` object
 * * event handlers using `on` object
 * * hammer handlers using `hammer` object
 * * data binding using `bind` object
 * * store element references to a container object using `storeTo` object
 *
 *
 */</span>
<span class="hljs-comment">/*global define, Node, document*/</span>
define( [ <span class="hljs-string">"yasmf/util/object"</span> ], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( BaseObject )</span> </span>{
<span class="hljs-pi">  "use strict"</span>;
  <span class="hljs-comment">/**
   *
   * internal private method to handle parsing children
   * and attaching them to their parents
   *
   * If the child is a `Node`, it is attached directly to the parent as a child
   * If the child is a `function`, the *resuts* are re-parsed, ultimately to be attached to the parent
   *   as children
   * If the child is an `Array`, each element within the array is re-parsed, ultimately to be attached
   *   to the parent as children
   *
   * @method handleChild
   * @private
   * @param {Array|Function|Node} child       child to handle and attach
   * @param {Node} parent                     parent
   *
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleChild</span><span class="hljs-params">( child, parent )</span> </span>{
      <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> child === <span class="hljs-string">"object"</span> ) {
        <span class="hljs-keyword">if</span> ( child <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span> ) {
          <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, l = child.length; i &lt; l; i++ ) {
            handleChild( child[ i ], parent );
          }
        }
        <span class="hljs-keyword">if</span> ( child <span class="hljs-keyword">instanceof</span> Node ) {
          parent.appendChild( child );
        }
      }
      <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> child === <span class="hljs-string">"function"</span> ) {
        handleChild( child(), parent );
      }
    }
    <span class="hljs-comment">/**
     * parses an incoming tag into its tag `name`, `id`, and `class` constituents
     * A tag is of the form `tagName.class#id` or `tagName#id.class`. The `id` and `class`
     * are optional.
     *
     * If attributes need to be supplied, it's possible via the `?` query string. Attributes
     * are of the form `?attr=value&amp;attr=value...`.
     *
     * @method parseTag
     * @private
     * @param {string} tag      tag to parse
     * @return {*} Object of the form `{ tag: tagName, id: id, class: class, query: query, queryPars: Array }`
     */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseTag</span><span class="hljs-params">( tag )</span> </span>{
      <span class="hljs-keyword">var</span> tagParts = {
          tag: <span class="hljs-string">""</span>,
          id: <span class="hljs-literal">undefined</span>,
          <span class="hljs-keyword">class</span>: <span class="hljs-literal">undefined</span>,
          query: <span class="hljs-literal">undefined</span>,
          queryParts: []
        },
        hashPos = tag.indexOf( <span class="hljs-string">"#"</span> ),
        dotPos = tag.indexOf( <span class="hljs-string">"."</span> ),
        qmPos = tag.indexOf( <span class="hljs-string">"?"</span> );
      <span class="hljs-keyword">if</span> ( qmPos &gt;= <span class="hljs-number">0</span> ) {
        tagParts.query = tag.substr( qmPos + <span class="hljs-number">1</span> );
        tagParts.queryParts = tagParts.query.split( <span class="hljs-string">"&amp;"</span> );
        tag = tag.substr( <span class="hljs-number">0</span>, qmPos );
      }
      <span class="hljs-keyword">if</span> ( hashPos &lt; <span class="hljs-number">0</span> &amp;&amp; dotPos &lt; <span class="hljs-number">0</span> ) {
        tagParts.tag = tag;
        <span class="hljs-keyword">return</span> tagParts;
      }
      <span class="hljs-keyword">if</span> ( hashPos &gt;= <span class="hljs-number">0</span> &amp;&amp; dotPos &lt; <span class="hljs-number">0</span> ) {
        tagParts.tag = tag.substr( <span class="hljs-number">0</span>, hashPos );
        tagParts.id = tag.substr( hashPos + <span class="hljs-number">1</span> );
        <span class="hljs-keyword">return</span> tagParts;
      }
      <span class="hljs-keyword">if</span> ( dotPos &gt;= <span class="hljs-number">0</span> &amp;&amp; hashPos &lt; <span class="hljs-number">0</span> ) {
        tagParts.tag = tag.substr( <span class="hljs-number">0</span>, dotPos );
        tagParts.class = tag.substr( dotPos + <span class="hljs-number">1</span> );
        <span class="hljs-keyword">return</span> tagParts;
      }
      <span class="hljs-keyword">if</span> ( dotPos &gt;= <span class="hljs-number">0</span> &amp;&amp; hashPos &gt;= <span class="hljs-number">0</span> &amp;&amp; hashPos &lt; dotPos ) {
        tagParts.tag = tag.substr( <span class="hljs-number">0</span>, hashPos );
        tagParts.id = tag.substr( hashPos + <span class="hljs-number">1</span>, ( dotPos - hashPos ) - <span class="hljs-number">1</span> );
        tagParts.class = tag.substr( dotPos + <span class="hljs-number">1</span> );
        <span class="hljs-keyword">return</span> tagParts;
      }
      <span class="hljs-keyword">if</span> ( dotPos &gt;= <span class="hljs-number">0</span> &amp;&amp; hashPos &gt;= <span class="hljs-number">0</span> &amp;&amp; dotPos &lt; hashPos ) {
        tagParts.tag = tag.substr( <span class="hljs-number">0</span>, dotPos );
        tagParts.class = tag.substr( dotPos + <span class="hljs-number">1</span>, ( hashPos - dotPos ) - <span class="hljs-number">1</span> );
        tagParts.id = tag.substr( hashPos + <span class="hljs-number">1</span> );
        <span class="hljs-keyword">return</span> tagParts;
      }
      <span class="hljs-keyword">return</span> tagParts;
    }
    <span class="hljs-comment">/**
     * h templating engine
     */</span>
  <span class="hljs-keyword">var</span> h = {
      VERSION: <span class="hljs-string">"0.1.100"</span>,
      <span class="hljs-comment">/**
       * Returns a DOM tree containing the requested element and any further child
       * elements (as extra parameters)
       *
       * `tagOptions` should be an object consisting of the following optional segments:
       *
       * ```
       * {
       *    attrs: {...}                     attributes to add to the element
       *    styles: {...}                    style attributes to add to the element
       *    on: {...}                        event handlers to attach to the element
       *    bind: { object:, keyPath:, keyType: }      data binding
       *    store: { object:, keyPath: }     store element to object.keyPath
       * }
       * ```
       *
       * @method el
       * @param {string} tag                 tag of the form `tagName.class#id` or `tagName#id.class`
       *                                     tag can also specify attributes:
       *                                        `input?type=text&amp;size=20`
       * @param {*} tagOptions               options for the tag (see above)
       * @param {Array|Function|String} ...  children that should be attached
       * @returns {Node}                     DOM tree
       *
       */</span>
      el: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( tag )</span> </span>{
        <span class="hljs-keyword">var</span> e, i, l, evt,
          options,
          content = [],
          contentTarget = [],
          bindValue,
          tagParts = parseTag( tag ); <span class="hljs-comment">// parse tag; it should be of the form `tag[#id][.class][?attr=value[&amp;attr=value...]`</span></pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>create the element; if <code>@DF</code> is used, a document fragment is used instead</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> ( tagParts.tag !== <span class="hljs-string">"@DF"</span> ) {
          e = <span class="hljs-built_in">document</span>.createElement( tagParts.tag );
        } <span class="hljs-keyword">else</span> {
          e = <span class="hljs-built_in">document</span>.createDocumentFragment();
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>attach the <code>class</code> and <code>id</code> from the tag name, if available</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> ( tagParts.class !== <span class="hljs-literal">undefined</span> ) {
          e.className = tagParts.class;
        }
        <span class="hljs-keyword">if</span> ( tagParts.id !== <span class="hljs-literal">undefined</span> ) {
          e.setAttribute( <span class="hljs-string">"id"</span>, tagParts.id );
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>get the arguments as an array, ignoring the first parameter</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call( <span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span> );</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>determine what we’ve passed in the second/third parameter
if it is an object (but not a node or array), it’s a list of
options to attach to the element. If it is a string, it’s text
content that should be added using <code>textContent</code> or <code>value</code></p>
<blockquote>
<p>note: we could parse the entire argument list, but that would
a bit absurd.</p>
</blockquote>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ ) {
          <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> args[ <span class="hljs-number">0</span> ] !== <span class="hljs-string">"undefined"</span> ) {
            <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> args[ <span class="hljs-number">0</span> ] === <span class="hljs-string">"object"</span> ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>could be a DOM node, an array, or tag options</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> ( !( args[ <span class="hljs-number">0</span> ] <span class="hljs-keyword">instanceof</span> Node ) &amp;&amp; !( args[ <span class="hljs-number">0</span> ] <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span> ) ) {
                options = args.shift();
              }
            }
            <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> args[ <span class="hljs-number">0</span> ] === <span class="hljs-string">"string"</span> || <span class="hljs-keyword">typeof</span> args[ <span class="hljs-number">0</span> ] === <span class="hljs-string">"number"</span> ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>this is text content</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              content.push( args.shift() );
            }
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>copy over any <code>queryParts</code> attributes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> ( tagParts.queryParts.length &gt; <span class="hljs-number">0</span> ) {
          <span class="hljs-keyword">var</span> arr;
          <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>, l = tagParts.queryParts.length; i &lt; l; i++ ) {
            arr = tagParts.queryParts[ i ].split( <span class="hljs-string">"="</span> );
            <span class="hljs-keyword">if</span> ( arr.length === <span class="hljs-number">2</span> ) {
              e.setAttribute( arr[ <span class="hljs-number">0</span> ].trim(), arr[ <span class="hljs-number">1</span> ].trim() );
            }
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>copy over any attributes and styles in <code>options.attrs</code> and <code>options.style</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> options === <span class="hljs-string">"object"</span> &amp;&amp; options !== <span class="hljs-literal">null</span> ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>add attributes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> ( options.attrs ) {
            <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> attr <span class="hljs-keyword">in</span> options.attrs ) {
              <span class="hljs-keyword">if</span> ( options.attrs.hasOwnProperty( attr ) ) {
                <span class="hljs-keyword">if</span> ( options.attrs[ attr ] !== <span class="hljs-literal">undefined</span> &amp;&amp; options.attrs[ attr ] !== <span class="hljs-literal">null</span> ) {
                  e.setAttribute( attr, options.attrs[ attr ] );
                }
              }
            }
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>add styles</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> ( options.styles ) {
            <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> style <span class="hljs-keyword">in</span> options.styles ) {
              <span class="hljs-keyword">if</span> ( options.styles.hasOwnProperty( style ) ) {
                <span class="hljs-keyword">if</span> ( options.styles[ style ] !== <span class="hljs-literal">undefined</span> &amp;&amp; options.styles[ style ] !== <span class="hljs-literal">null</span> ) {
                  e.style[ style ] = options.styles[ style ];
                }
              }
            }
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>add event handlers; handler property is expected to be a valid DOM
event, i.e. <code>{ &quot;change&quot;: function... }</code> or <code>{ change: function... }</code>
if the handler is an object, it must be of the form</p>
<pre><code>  { handler: <span class="hljs-function"><span class="hljs-keyword">function</span> ...,
    <span class="hljs-title">capture</span>: <span class="hljs-title">true</span>/<span class="hljs-title">false</span> }</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> ( options.on ) {
            <span class="hljs-keyword">for</span> ( evt <span class="hljs-keyword">in</span> options.on ) {
              <span class="hljs-keyword">if</span> ( options.on.hasOwnProperty( evt ) ) {
                <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> options.on[ evt ] === <span class="hljs-string">"function"</span> ) {
                  e.addEventListener( evt, options.on[ evt ].bind( e ), <span class="hljs-literal">false</span> );
                } <span class="hljs-keyword">else</span> {
                  e.addEventListener( evt, options.on[ evt ].handler.bind( e ), <span class="hljs-keyword">typeof</span> options.on[ evt ].capture !==
                    <span class="hljs-string">"undefined"</span> ? options.on[ evt ].capture : <span class="hljs-literal">false</span> );
                }
              }
            }
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>we support hammer too, assuming we’re given a reference
it must be of the form <code>{ hammer: { gesture: { handler: fn, options: }, hammer: hammer } }</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> ( options.hammer ) {
            <span class="hljs-keyword">var</span> hammer = options.hammer.hammer;
            <span class="hljs-keyword">for</span> ( evt <span class="hljs-keyword">in</span> options.hammer ) {
              <span class="hljs-keyword">if</span> ( options.hammer.hasOwnProperty( evt ) &amp;&amp; evt !== <span class="hljs-string">"hammer"</span> ) {
                hammer( e, options.hammer[ evt ].options ).on( evt, options.hammer[ evt ].handler );
              }
            }
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>allow elements to be stored into a context
store must be an object of the form <code>{object:objectRef, keyPath: &quot;keyPath&quot; }</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> ( options.store ) {
            options.store.object[ options.store.keyPath ] = e;
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>if we have content, go ahead and add it;
if we’re an element that has a <code>value</code>, we attach it to the value
property instead of <code>textContent</code>. If <code>textContent</code> is not available
we use <code>innerText</code>; if that’s not available, we complain and do
nothing. Falling back to <code>innerHTML</code> isn’t an option, as that’s what
we are explicitly trying to avoid.</p>
<p>First, determine if we have <code>value</code> and <code>textContent</code> options or only
<code>textContent</code> (buttons have both) If both are present, the first
content item is applied to <code>value</code>, and the second is applied to
<code>textContent</code>|<code>innerText</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> e.value !== <span class="hljs-string">"undefined"</span> ) {
          contentTarget.push( <span class="hljs-string">"value"</span> );
        }
        <span class="hljs-keyword">if</span> ( ( <span class="hljs-keyword">typeof</span> e.textContent !== <span class="hljs-string">"undefined"</span> ) || ( <span class="hljs-keyword">typeof</span> e.innerText !== <span class="hljs-string">"undefined"</span> ) ) {
          contentTarget.push( <span class="hljs-keyword">typeof</span> e.textContent !== <span class="hljs-string">"undefined"</span> ? <span class="hljs-string">"textContent"</span> : <span class="hljs-string">"innerText"</span> );
        }
        <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>, l = contentTarget.length; i &lt; l; i++ ) {
          <span class="hljs-keyword">var</span> x = content.shift();
          <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> x !== <span class="hljs-string">"undefined"</span> ) {
            e[ contentTarget[ i ] ] = x;
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>Handle children; <code>handleChild</code> appends each one to the parent</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> child;
        <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>, l = args.length; i &lt; l; i++ ) {
          child = args[ i ];
          handleChild( child, e );
        }
        <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> options === <span class="hljs-string">"object"</span> &amp;&amp; options !== <span class="hljs-literal">null</span> ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Data binding only occurs if using YASMF’s BaseObject for now (built-in pubsub/observables)
along with observable properties
the binding object is of the form <code>{ object: objectRef, keyPath: &quot;keyPath&quot;, [keyType:&quot;string&quot;] }</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> ( options.bind ) {
            <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> BaseObject !== <span class="hljs-string">"undefined"</span> ) {
              <span class="hljs-keyword">if</span> ( options.bind.object <span class="hljs-keyword">instanceof</span> BaseObject ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>we have an object that has observable properties</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                options.bind.object.dataBindOn( e, options.bind.keyPath, options.bind.keyType );
                options.bind.object.notifyDataBindingElementsForKeyPath( options.bind.keyPath );
                <span class="hljs-comment">/*// get the current value so it can be displayed
                 if ( options.bind.object[ options.bind.keyPath ] !== undefined ) {
                 if ( e.value !== undefined ) {
                 e.value = options.bind.object[ options.bind.keyPath ];
                 } else {
                 e.textContent = options.bind.object[ options.bind.keyPath ];
                 }
                 }*/</span>
              }
            }
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>return the element (and associated tree)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> e;
      },
      <span class="hljs-comment">/**
       * mapTo - Maps a keypath to another keypath based on `map`. `map` should look like this:
       *
       * ```
       * {
       *   "mapping_key": "target_key", ...
       * }
       * ```
       *
       * For example, let's assume that some object `o` has the properties `id` and `name`. We
       * want to map these to consistent values like `value` and `description` for a component.
       * `map` should look like this: `{ "value": "id", "description": "name" }`. In this case
       * calling `mapTo("value", map)` would return `id`, which could then be indexed on `o`
       * like so: `o[mapTo("value",map)]`.
       *
       * @method mapTo
       * @param  {String}    keyPath to map
       * @param  {*} map     map description
       * @return {String}    mapped keyPath
       */</span>
      mapTo: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mapTo</span><span class="hljs-params">( keyPath, map )</span> </span>{
        <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> map === <span class="hljs-string">"undefined"</span> ) {
          <span class="hljs-keyword">return</span> keyPath;
        }
        <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> map[ keyPath ] !== <span class="hljs-string">"undefined"</span> ) {
          <span class="hljs-keyword">return</span> map[ keyPath ];
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> keyPath;
        }
      },
      <span class="hljs-comment">/**
       * iif - evaluate `expr` and if it is `true`, return `a`. If it is false,
       * return `b`. If `a` is not supplied, `true` is the return result if `a`
       * would have been returned. If `b` is not supplied, `false` is the return
       * result if `b` would have been returned. Not much difference than the
       * ternary (`?:`) operator, but might be easier to read for some.
       *
       * @method iif
       * @param  {boolean} expr expression to evaluate
       * @param  {*} a     value to return if `expr` is true; `true` is the default if not supplied
       * @param  {*} b     value to return if `expr` is false; `false` is the default if not supplied
       * @return {*}       `expr ? a : b`
       */</span>
      iif: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">iif</span><span class="hljs-params">( expr, a, b )</span> </span>{
        <span class="hljs-keyword">return</span> expr ? ( ( <span class="hljs-keyword">typeof</span> a !== <span class="hljs-string">"undefined"</span> ) ? a : <span class="hljs-literal">true</span> ) : ( ( <span class="hljs-keyword">typeof</span> b !== <span class="hljs-string">"undefined"</span> ) ? b : <span class="hljs-literal">false</span> );
      },
      <span class="hljs-comment">/**
       * ifdef - Check if an expression is defined and return `a` if it is and `b`
       * if it isn't. If `a` is not supplied, `a` evaluates to `true` and if `b`
       * is not supplied, `b` evaluates to `false`.
       *
       * @method ifdef
       * @param  {boolean} expr expression to check
       * @param  {*}       a    value to return if expression is defined
       * @param  {*}       b    value to return if expression is not defined
       * @return {*}       a or b
       */</span>
      ifdef: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ifdef</span><span class="hljs-params">( expr, a, b )</span> </span>{
        <span class="hljs-keyword">return</span> ( <span class="hljs-keyword">typeof</span> expr !== <span class="hljs-string">"undefined"</span> ) ? ( ( <span class="hljs-keyword">typeof</span> a !== <span class="hljs-string">"undefined"</span> ) ? a : <span class="hljs-literal">true</span> ) : ( ( <span class="hljs-keyword">typeof</span> b !== <span class="hljs-string">"undefined"</span> ) ?
          b : <span class="hljs-literal">false</span> );
      },
      <span class="hljs-comment">/**
       * forIn - return an array containing the results of calling `fn` for
       * each property within `object`. Equivalent to `map` on an array.
       *
       * The function should have the signature `( value, object, property )`
       * and return the result. The results will automatically be collated in
       * an array.
       *
       * @method forIn
       * @param  {*}        object object to iterate over
       * @param  {function} fn     function to call
       * @return {Array}           resuts
       */</span>
      forIn: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forIn</span><span class="hljs-params">( object, fn )</span> </span>{
        <span class="hljs-keyword">var</span> arr = [];
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> prop <span class="hljs-keyword">in</span> object ) {
          <span class="hljs-keyword">if</span> ( object.hasOwnProperty( prop ) ) {
            arr.push( fn( object[ prop ], object, prop ) );
          }
        }
        <span class="hljs-keyword">return</span> arr;
      },
      <span class="hljs-comment">/**
       * forEach - Executes `map` on an array, calling `fn`. Named such because
       * it makes more sense than using `map` in a template, but it means the
       * same thing.
       *
       * @method forEach
       * @param  {Array}    arr Array to iterate
       * @param  {function} fn  Function to call
       * @return {Array}        Array after iteration
       */</span>
      forEach: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forEach</span><span class="hljs-params">( arr, fn )</span> </span>{
        <span class="hljs-keyword">return</span> arr.map( fn );
      },
      <span class="hljs-comment">/**
       * renderTo - Renders a node or array of nodes to a given element. If an
       * array is provided, each is appended in turn.
       *
       * Note: technically you can just use `appendChild` or equivalent DOM
       * methods, but this works only as far as the return result is a single
       * node. Occasionally your template may return an array of nodes, and
       * at that point `appendChild` fails.
       *
       * @method renderTo
       * @param  {Array|Node} n  Array or single node to append to the element
       * @param  {Node} el Element to attach to
       * @param  {Number} idx  index (optional)
       */</span>
      renderTo: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderTo</span><span class="hljs-params">( n, el, idx )</span> </span>{
        <span class="hljs-keyword">if</span> ( !idx ) {
          idx = <span class="hljs-number">0</span>;
        }
        <span class="hljs-keyword">if</span> ( n <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span> ) {
          <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, l = n.length; i &lt; l; i++ ) {
            renderTo( n[ i ], el, i );
          }
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">if</span> ( el.hasChildNodes() &amp;&amp; idx &lt; el.childNodes.length ) {
            el.replaceChild( n, el.childNodes[ idx ] );
          } <span class="hljs-keyword">else</span> {
            el.appendChild( n );
          }
        }
      }
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>create bindings for each HTML element (from: <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element">https://developer.mozilla.org/en-US/docs/Web/HTML/Element</a>)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    els = [ <span class="hljs-string">"a"</span>, <span class="hljs-string">"abbr"</span>, <span class="hljs-string">"acronym"</span>, <span class="hljs-string">"address"</span>, <span class="hljs-string">"applet"</span>, <span class="hljs-string">"area"</span>, <span class="hljs-string">"article"</span>, <span class="hljs-string">"aside"</span>, <span class="hljs-string">"audio"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"base"</span>, <span class="hljs-string">"basefont"</span>, <span class="hljs-string">"bdi"</span>,
      <span class="hljs-string">"bdo"</span>, <span class="hljs-string">"bgsound"</span>, <span class="hljs-string">"big"</span>, <span class="hljs-string">"blink"</span>, <span class="hljs-string">"blockquote"</span>, <span class="hljs-string">"body"</span>, <span class="hljs-string">"br"</span>, <span class="hljs-string">"button"</span>, <span class="hljs-string">"canvas"</span>, <span class="hljs-string">"caption"</span>, <span class="hljs-string">"center"</span>, <span class="hljs-string">"cite"</span>, <span class="hljs-string">"code"</span>,
      <span class="hljs-string">"col"</span>, <span class="hljs-string">"colgroup"</span>, <span class="hljs-string">"content"</span>, <span class="hljs-string">"data"</span>, <span class="hljs-string">"datalist"</span>, <span class="hljs-string">"dd"</span>, <span class="hljs-string">"decorator"</span>, <span class="hljs-string">"del"</span>, <span class="hljs-string">"details"</span>, <span class="hljs-string">"dfn"</span>, <span class="hljs-string">"dialog"</span>, <span class="hljs-string">"dir"</span>, <span class="hljs-string">"div"</span>,
      <span class="hljs-string">"dl"</span>, <span class="hljs-string">"dt"</span>, <span class="hljs-string">"element"</span>, <span class="hljs-string">"em"</span>, <span class="hljs-string">"embed"</span>, <span class="hljs-string">"fieldset"</span>, <span class="hljs-string">"figcaption"</span>, <span class="hljs-string">"figure"</span>, <span class="hljs-string">"font"</span>, <span class="hljs-string">"footer"</span>, <span class="hljs-string">"form"</span>, <span class="hljs-string">"frameset"</span>, <span class="hljs-string">"h1"</span>,
      <span class="hljs-string">"h2"</span>, <span class="hljs-string">"h3"</span>, <span class="hljs-string">"h4"</span>, <span class="hljs-string">"h5"</span>, <span class="hljs-string">"h6"</span>, <span class="hljs-string">"head"</span>, <span class="hljs-string">"header"</span>, <span class="hljs-string">"hgroup"</span>, <span class="hljs-string">"hr"</span>, <span class="hljs-string">"html"</span>, <span class="hljs-string">"i"</span>, <span class="hljs-string">"iframe"</span>, <span class="hljs-string">"img"</span>, <span class="hljs-string">"input"</span>, <span class="hljs-string">"ins"</span>, <span class="hljs-string">"isindex"</span>,
      <span class="hljs-string">"kbd"</span>, <span class="hljs-string">"keygen"</span>, <span class="hljs-string">"label"</span>, <span class="hljs-string">"legend"</span>, <span class="hljs-string">"li"</span>, <span class="hljs-string">"link"</span>, <span class="hljs-string">"listing"</span>, <span class="hljs-string">"main"</span>, <span class="hljs-string">"map"</span>, <span class="hljs-string">"mark"</span>, <span class="hljs-string">"marquee"</span>, <span class="hljs-string">"menu"</span>, <span class="hljs-string">"menuitem"</span>, <span class="hljs-string">"meta"</span>,
      <span class="hljs-string">"meter"</span>, <span class="hljs-string">"nav"</span>, <span class="hljs-string">"nobr"</span>, <span class="hljs-string">"noframes"</span>, <span class="hljs-string">"noscript"</span>, <span class="hljs-string">"object"</span>, <span class="hljs-string">"ol"</span>, <span class="hljs-string">"optgroup"</span>, <span class="hljs-string">"option"</span>, <span class="hljs-string">"output"</span>, <span class="hljs-string">"p"</span>, <span class="hljs-string">"param"</span>, <span class="hljs-string">"picture"</span>,
      <span class="hljs-string">"plaintext"</span>, <span class="hljs-string">"pre"</span>, <span class="hljs-string">"progress"</span>, <span class="hljs-string">"q"</span>, <span class="hljs-string">"rp"</span>, <span class="hljs-string">"rt"</span>, <span class="hljs-string">"ruby"</span>, <span class="hljs-string">"s"</span>, <span class="hljs-string">"samp"</span>, <span class="hljs-string">"script"</span>, <span class="hljs-string">"section"</span>, <span class="hljs-string">"select"</span>, <span class="hljs-string">"shadow"</span>, <span class="hljs-string">"small"</span>,
      <span class="hljs-string">"source"</span>, <span class="hljs-string">"spacer"</span>, <span class="hljs-string">"span"</span>, <span class="hljs-string">"strike"</span>, <span class="hljs-string">"strong"</span>, <span class="hljs-string">"style"</span>, <span class="hljs-string">"sub"</span>, <span class="hljs-string">"summary"</span>, <span class="hljs-string">"sup"</span>, <span class="hljs-string">"table"</span>, <span class="hljs-string">"tbody"</span>, <span class="hljs-string">"td"</span>, <span class="hljs-string">"template"</span>,
      <span class="hljs-string">"textarea"</span>, <span class="hljs-string">"tfoot"</span>, <span class="hljs-string">"th"</span>, <span class="hljs-string">"thead"</span>, <span class="hljs-string">"time"</span>, <span class="hljs-string">"title"</span>, <span class="hljs-string">"tr"</span>, <span class="hljs-string">"track"</span>, <span class="hljs-string">"tt"</span>, <span class="hljs-string">"u"</span>, <span class="hljs-string">"ul"</span>, <span class="hljs-string">"var"</span>, <span class="hljs-string">"video"</span>, <span class="hljs-string">"wbr"</span>, <span class="hljs-string">"xmp"</span>
    ];
  els.forEach( <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( el )</span> </span>{
    h[ el ] = h.el.bind( h, el );
  } );</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>bind document fragment too</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  h.DF = h.el.bind( h, <span class="hljs-string">"@DF"</span> );
  h.dF = h.DF;
  <span class="hljs-keyword">return</span> h;
} );</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
