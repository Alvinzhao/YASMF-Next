<!DOCTYPE html>

<html>
<head>
  <title>object.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="core.html">
                core.js
              </a>
            
              
              <a class="source" href="datetime.html">
                datetime.js
              </a>
            
              
              <a class="source" href="device.html">
                device.js
              </a>
            
              
              <a class="source" href="fileManager.html">
                fileManager.js
              </a>
            
              
              <a class="source" href="filename.html">
                filename.js
              </a>
            
              
              <a class="source" href="h.html">
                h.js
              </a>
            
              
              <a class="source" href="misc.html">
                misc.js
              </a>
            
              
              <a class="source" href="object.html">
                object.js
              </a>
            
              
              <a class="source" href="router.html">
                router.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>object.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-comment">/**
 *
 * # Base Object
 *
 * @module object.js
 * @author Kerri Shotts
 * @version 0.5
 * ```
 * Copyright (c) 2013 Kerri Shotts, photoKandy Studios LLC
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this
 * software and associated documentation files (the "Software"), to deal in the Software
 * without restriction, including without limitation the rights to use, copy, modify,
 * merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following
 * conditions:
 * The above copyright notice and this permission notice shall be included in all copies
 * or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
 * PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
 * OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 * ```
 */</span>
<span class="hljs-comment">/*global define, console, setTimeout*/</span>
define( <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
<span class="hljs-pi">  "use strict"</span>;
  <span class="hljs-keyword">var</span> _className = <span class="hljs-string">"BaseObject"</span>,
    <span class="hljs-comment">/**
     * BaseObject is the base object for all complex objects used by YASMF;
     * simpler objects that are properties-only do not inherit from this
     * class.
     *
     * BaseObject provides simple inheritance, but not by using the typical
     * prototypal method. Rather inheritance is formed by object composition
     * where all objects are instances of BaseObject with methods overridden
     * instead. As such, you can *not* use any Javascript type checking to
     * differentiate PKObjects; you should instead use the `class`
     * property.
     *
     * BaseObject provides inheritance to more than just a constructor: any
     * method can be overridden, but it is critical that the super-chain
     * be properly initialized. See the `super` and `overrideSuper`
     * methods for more information.
     *
     * @class BaseObject
     */</span>
    BaseObject = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
      <span class="hljs-comment">/**
       *
       * We need a way to provide inheritance. Most methods only provide
       * inheritance across the constructor chain, not across any possible
       * method. But for our purposes, we need to be able to provide for
       * overriding any method (such as drawing, touch responses, etc.),
       * and so we implement inheritance in a different way.
       *
       * First, the _classHierarchy, a private property, provides the
       * inheritance tree. All objects inherit from "BaseObject".
       *
       * @private
       * @property _classHierarchy
       * @type Array
       * @default ["BaseObject"]
       */</span>
      self._classHierarchy = [ _className ];
      <span class="hljs-comment">/**
       *
       * Objects are subclassed using this method. The newClass is the
       * unique class name of the object (and should match the class'
       * actual name.
       *
       * @method subclass
       * @param {String} newClass - the new unique class of the object
       */</span>
      self.subclass = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( newClass )</span> </span>{
        self._classHierarchy.push( newClass );
      };
      <span class="hljs-comment">/**
       *
       * getClass returns the current class of the object. The
       * `class` property can be used as well. Note that there
       * is no `setter` for this property; an object's class
       * can *not* be changed.
       *
       * @method getClass
       * @returns {String} the class of the instance
       *
       */</span>
      self.getClass = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> self._classHierarchy[ self._classHierarchy.length - <span class="hljs-number">1</span> ];
      };
      <span class="hljs-comment">/**
       *
       * The class of the instance. **Read-only**
       * @property class
       * @type String
       * @readOnly
       */</span>
      <span class="hljs-built_in">Object</span>.defineProperty( self, <span class="hljs-string">"class"</span>, {
        get: self.getClass,
        configurable: <span class="hljs-literal">false</span>
      } );
      <span class="hljs-comment">/**
       *
       * Returns the super class for the given class. If the
       * class is not supplied, the class is assumed to be the
       * object's own class.
       *
       * The property "superClass" uses this to return the
       * object's direct superclass, but getSuperClassOfClass
       * can be used to determine superclasses higher up
       * the hierarchy.
       *
       * @method getSuperClassOfClass
       * @param {String} [aClass=currentClass] the class for which you want the super class. If not specified,
       *                                        the instance's class is used.
       * @returns {String} the super-class of the specified class.
       */</span>
      self.getSuperClassOfClass = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( aClass )</span> </span>{
        <span class="hljs-keyword">var</span> theClass = aClass || self.class;
        <span class="hljs-keyword">var</span> i = self._classHierarchy.indexOf( theClass );
        <span class="hljs-keyword">if</span> ( i &gt; -<span class="hljs-number">1</span> ) {
          <span class="hljs-keyword">return</span> self._classHierarchy[ i - <span class="hljs-number">1</span> ];
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }
      };
      <span class="hljs-comment">/**
       *
       * The superclass of the instance.
       * @property superClass
       * @type String
       */</span>
      <span class="hljs-built_in">Object</span>.defineProperty( self, <span class="hljs-string">"superClass"</span>, {
        get: self.getSuperClassOfClass,
        configurable: <span class="hljs-literal">false</span>
      } );
      <span class="hljs-comment">/**
       *
       * _super is an object that stores overridden functions by class and method
       * name. This is how we get the ability to arbitrarily override any method
       * already present in the superclass.
       *
       * @private
       * @property _super
       * @type Object
       */</span>
      self._super = {};
      <span class="hljs-comment">/**
       *
       * Must be called prior to defining the overridden function as this moves
       * the original function into the _super object. The functionName must
       * match the name of the method exactly, since there may be a long tree
       * of code that depends on it.
       *
       * @method overrideSuper
       * @param {String} theClass  the class for which the function override is desired
       * @param {String} theFunctionName  the name of the function to override
       * @param {Function} theActualFunction  the actual function (or pointer to function)
       *
       */</span>
      self.overrideSuper = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( theClass, theFunctionName, theActualFunction )</span> </span>{
        <span class="hljs-keyword">var</span> superClass = self.getSuperClassOfClass( theClass );
        <span class="hljs-keyword">if</span> ( !self._super[ superClass ] ) {
          self._super[ superClass ] = {};
        }
        self._super[ superClass ][ theFunctionName ] = theActualFunction;
      };
      <span class="hljs-comment">/**
       * @method override
       *
       * Overrides an existing function with the same name as `theNewFunction`. Essentially
       * a call to `overrideSuper (self.class, theNewFunction.name, self[theNewFunction.name])`
       * followed by the redefinition of the function.
       *
       * @example
       * ```
       * obj.override ( function initWithOptions ( options )
       *                { ... } );
       * ```
       *
       * @param {Function} theNewFunction - The function to override. Must have the name of the overriding function.
       */</span>
      self.override = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( theNewFunction )</span> </span>{
        <span class="hljs-keyword">var</span> theFunctionName = theNewFunction.name;
        <span class="hljs-keyword">if</span> ( theFunctionName !== <span class="hljs-string">""</span> ) {
          self.overrideSuper( self.class, theFunctionName, self[ theFunctionName ] );
          self[ theFunctionName ] = theNewFunction;
        }
      };
      <span class="hljs-comment">/**
       *
       * Calls a super function with any number of arguments.
       *
       * @method super
       * @param {String} theClass  the current class instance
       * @param {String} theFunctionName the name of the function to execute
       * @param {Array} [args]  Any number of parameters to pass to the super method
       *
       */</span>
      self.super = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( theClass, theFunctionName, args )</span> </span>{
        <span class="hljs-keyword">var</span> superClass = self.getSuperClassOfClass( theClass );
        <span class="hljs-keyword">if</span> ( self._super[ superClass ] ) {
          <span class="hljs-keyword">if</span> ( self._super[ superClass ][ theFunctionName ] ) {
            <span class="hljs-keyword">return</span> self._super[ superClass ][ theFunctionName ].apply( self, args );
          }
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      };
      <span class="hljs-comment">/**
       * Category support; for an object to get category support for their class,
       * they must call this method prior to any auto initialization
       *
       * @method _constructObjectCategories
       *
       */</span>
      self._constructObjectCategories = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_constructObjectCategories</span><span class="hljs-params">( pri )</span> </span>{
        <span class="hljs-keyword">var</span> priority = BaseObject.ON_CREATE_CATEGORY;
        <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> pri !== <span class="hljs-string">"undefined"</span> ) {
          priority = pri;
        }
        <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> BaseObject._objectCategories[ priority ][ self.class ] !== <span class="hljs-string">"undefined"</span> ) {
          BaseObject._objectCategories[ priority ][ self.class ].forEach( <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( categoryConstructor )</span> </span>{
            <span class="hljs-keyword">try</span> {
              categoryConstructor( self );
            } <span class="hljs-keyword">catch</span> ( e ) {
              <span class="hljs-built_in">console</span>.log( <span class="hljs-string">"Error during category construction: "</span> + e.message );
            }
          } );
        }
      };
      <span class="hljs-comment">/**
       *
       * initializes the object
       *
       * @method init
       *
       */</span>
      self.init = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        self._constructObjectCategories( BaseObject.ON_INIT_CATEGORY );
        <span class="hljs-keyword">return</span> self;
      };
      <span class="hljs-comment">/*
       *
       * Objects have some properties that we want all objects to have...
       *
       */</span>
      <span class="hljs-comment">/**
       * Stores the values of all the tags associated with the instance.
       *
       * @private
       * @property _tag
       * @type Object
       */</span>
      self._tags = {};
      <span class="hljs-comment">/**
       *
       * Stores the *listeners* for all the tags associated with the instance.
       *
       * @private
       * @property _tagListeners
       * @type Object
       */</span>
      self._tagListeners = {};
      <span class="hljs-comment">/**
       *
       * Sets the value for a specific tag associated with the instance. If the
       * tag does not exist, it is created.
       *
       * Any listeners attached to the tag via `addTagListenerForKey` will be
       * notified of the change. Listeners are passed three parameters:
       * `self` (the originating instance),
       * `theKey` (the tag being changed),
       * and `theValue` (the value of the tag); the tag is *already* changed
       *
       * @method setTagForKey
       * @param {*} theKey  the name of the tag; "__default" is special and
       *                     refers to the default tag visible via the `tag`
       *                     property.
       * @param {*} theValue  the value to assign to the tag.
       *
       */</span>
      self.setTagForKey = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( theKey, theValue )</span> </span>{
        self._tags[ theKey ] = theValue;
        <span class="hljs-keyword">var</span> notifyListener = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( theListener, theKey, theValue )</span> </span>{
          <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            theListener( self, theKey, theValue );
          };
        };
        <span class="hljs-keyword">if</span> ( self._tagListeners[ theKey ] ) {
          <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; self._tagListeners[ theKey ].length; i++ ) {
            setTimeout( notifyListener( self._tagListeners[ theKey ][ i ], theKey, theValue ), <span class="hljs-number">0</span> );
          }
        }
      };
      <span class="hljs-comment">/**
       *
       * Returns the value for a given key. If the key does not exist, the
       * result is undefined.
       *
       * @method getTagForKey
       * @param {*} theKey  the tag; "__default" is special and refers to
       *                     the default tag visible via the `tag` property.
       * @returns {*} the value of the key
       *
       */</span>
      self.getTagForKey = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( theKey )</span> </span>{
        <span class="hljs-keyword">return</span> self._tags[ theKey ];
      };
      <span class="hljs-comment">/**
       *
       * Add a listener to a specific tag. The listener will receive three
       * parameters whenever the tag changes (though they are optional). The tag
       * itself doesn't need to exist in order to assign a listener to it.
       *
       * The first parameter is the object for which the tag has been changed.
       * The second parameter is the tag being changed, and the third parameter
       * is the value of the tag. **Note:** the value has already changed by
       * the time the listener is called.
       *
       * @method addListenerForKey
       * @param {*} theKey The tag for which to add a listener; `__default`
       *                     is special and refers the default tag visible via
       *                     the `tag` property.
       * @param {Function} theListener  the function (or reference) to call
       *                    when the value changes.
       */</span>
      self.addTagListenerForKey = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( theKey, theListener )</span> </span>{
        <span class="hljs-keyword">if</span> ( !self._tagListeners[ theKey ] ) {
          self._tagListeners[ theKey ] = [];
        }
        self._tagListeners[ theKey ].push( theListener );
      };
      <span class="hljs-comment">/**
       *
       * Removes a listener from being notified when a tag changes.
       *
       * @method removeTagListenerForKey
       * @param {*} theKey  the tag from which to remove the listener; `__default`
       *                     is special and refers to the default tag visible via
       *                     the `tag` property.
       * @param {Function} theListener  the function (or reference) to remove.
       *
       */</span>
      self.removeTagListenerForKey = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( theKey, theListener )</span> </span>{
        <span class="hljs-keyword">if</span> ( !self._tagListeners[ theKey ] ) {
          self._tagListeners[ theKey ] = [];
        }
        <span class="hljs-keyword">var</span> i = self._tagListeners[ theKey ].indexOf( theListener );
        <span class="hljs-keyword">if</span> ( i &gt; -<span class="hljs-number">1</span> ) {
          self._tagListeners[ theKey ].splice( i, <span class="hljs-number">1</span> );
        }
      };
      <span class="hljs-comment">/**
       *
       * Sets the value for the simple tag (`__default`). Any listeners attached
       * to `__default` will be notified.
       *
       * @method setTag
       * @param {*} theValue  the value for the tag
       *
       */</span>
      self.setTag = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( theValue )</span> </span>{
        self.setTagForKey( <span class="hljs-string">"__default"</span>, theValue );
      };
      <span class="hljs-comment">/**
       *
       * Returns the value for the given tag (`__default`). If the tag has never been
       * set, the result is undefined.
       *
       * @method getTag
       * @returns {*} the value of the tag.
       */</span>
      self.getTag = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> self.getTagForKey( <span class="hljs-string">"__default"</span> );
      };
      <span class="hljs-comment">/**
       *
       * The default tag for the instance. Changing the tag itself (not any sub-properties of an object)
       * will notify any listeners attached to `__default`.
       *
       * @property tag
       * @type *
       *
       */</span>
      <span class="hljs-built_in">Object</span>.defineProperty( self, <span class="hljs-string">"tag"</span>, {
        get: self.getTag,
        set: self.setTag,
        configurable: <span class="hljs-literal">true</span>
      } );
      <span class="hljs-comment">/**
       *
       * All objects subject notifications for events
       *
       */</span>
      <span class="hljs-comment">/**
       * Supports notification listeners.
       * @private
       * @property _notificationListeners
       * @type Object
       */</span>
      self._notificationListeners = {};
      <span class="hljs-comment">/**
       * Adds a listener for a notification. If a notification has not been
       * registered (via `registerNotification`), an error is logged on the console
       * and the function returns without attaching the listener. This means if
       * you aren't watching the console, the function fails nearly silently.
       *
       * &gt; By default, no notifications are registered.
       *
       * If the first parameter is an object, multiple listeners can be registered:
       * { "viewWillAppear": handler, "viewDidAppear": handler2}.
       *
       * @method addListenerForNotification
       * @alias on
       * @param {String|*} theNotification  the name of the notification
       * @param {Function} theListener  the function (or reference) to be called when the
       *                                notification is triggered.
       * @returns {*} returns self for chaining
       */</span>
      self.addListenerForNotification = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( theNotification, theListener, async )</span> </span>{
        <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> theNotification === <span class="hljs-string">"object"</span> ) {
          <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> n <span class="hljs-keyword">in</span> theNotification ) {
            <span class="hljs-keyword">if</span> ( theNotification.hasOwnProperty( n ) ) {
              self.addListenerForNotification( n, theNotification[ n ], theListener ); <span class="hljs-comment">// async would shift up</span>
            }
          }
          <span class="hljs-keyword">return</span> self;
        }
        <span class="hljs-keyword">if</span> ( !self._notificationListeners[ theNotification ] ) {
          self.registerNotification( theNotification, ( <span class="hljs-keyword">typeof</span> async !== <span class="hljs-string">"undefined"</span> ) ? async : <span class="hljs-literal">false</span> );
        }
        self._notificationListeners[ theNotification ].push( theListener );
        <span class="hljs-keyword">if</span> ( self._traceNotifications ) {
          <span class="hljs-built_in">console</span>.log( <span class="hljs-string">"Adding listener "</span> + theListener + <span class="hljs-string">" for notification "</span> + theNotification );
        }
        <span class="hljs-keyword">return</span> self;
      };
      self.on = self.addListenerForNotification;
      <span class="hljs-comment">/**
       * Removes a listener from a notification. If a notification has not been
       * registered (via `registerNotification`), an error is logged on the console
       * and the function returns without attaching the listener. This means if
       * you aren't watching the console, the function fails nearly silently.
       *
       * &gt; By default, no notifications are registered.
       *
       * @method removeListenerForNotification
       * @alias off
       * @param {String} theNotification  the notification
       * @param {Function} theListener  The function or reference to remove
       */</span>
      self.removeListenerForNotification = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( theNotification, theListener )</span> </span>{
        <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> theNotification === <span class="hljs-string">"object"</span> ) {
          <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> n <span class="hljs-keyword">in</span> theNotification ) {
            <span class="hljs-keyword">if</span> ( theNotification.hasOwnProperty( n ) ) {
              self.removeListenerForNotification( n, theNotification[ n ] );
            }
          }
          <span class="hljs-keyword">return</span> self;
        }
        <span class="hljs-keyword">if</span> ( !self._notificationListeners[ theNotification ] ) {
          <span class="hljs-built_in">console</span>.log( theNotification + <span class="hljs-string">" has not been registered."</span> );
          <span class="hljs-keyword">return</span> self;
        }
        <span class="hljs-keyword">var</span> i = self._notificationListeners[ theNotification ].indexOf( theListener );
        <span class="hljs-keyword">if</span> ( self._traceNotifications ) {
          <span class="hljs-built_in">console</span>.log( <span class="hljs-string">"Removing listener "</span> + theListener + <span class="hljs-string">" (index: "</span> + i + <span class="hljs-string">") from  notification "</span> + theNotification );
        }
        <span class="hljs-keyword">if</span> ( i &gt; -<span class="hljs-number">1</span> ) {
          self._notificationListeners[ theNotification ].splice( i, <span class="hljs-number">1</span> );
        }
        <span class="hljs-keyword">return</span> self;
      };
      self.off = self.removeListenerForNotification;
      <span class="hljs-comment">/**
       * Registers a notification so that listeners can then be attached. Notifications
       * should be registered as soon as possible, otherwise listeners may attempt to
       * attach to a notification that isn't registered.
       *
       * @method registerNotification
       * @param {String} theNotification  the name of the notification.
       * @param {Boolean} async  if true, notifications are sent wrapped in setTimeout
       */</span>
      self.registerNotification = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( theNotification, async )</span> </span>{
        <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> self._notificationListeners[ theNotification ] === <span class="hljs-string">"undefined"</span> ) {
          self._notificationListeners[ theNotification ] = [];
          self._notificationListeners[ theNotification ]._useAsyncNotifications = ( <span class="hljs-keyword">typeof</span> async !== <span class="hljs-string">"undefined"</span> ? async : <span class="hljs-literal">true</span> );
        }
        <span class="hljs-keyword">if</span> ( self._traceNotifications ) {
          <span class="hljs-built_in">console</span>.log( <span class="hljs-string">"Registering notification "</span> + theNotification );
        }
      };
      self._traceNotifications = <span class="hljs-literal">false</span>;

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_doNotification</span><span class="hljs-params">( theNotification, options )</span> </span>{
        <span class="hljs-keyword">var</span> args,
          lastOnly = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> options !== <span class="hljs-string">"undefined"</span> ) {
          args = ( <span class="hljs-keyword">typeof</span> options.args !== <span class="hljs-string">"undefined"</span> ) ? options.args : <span class="hljs-literal">undefined</span>;
          lastOnly = ( <span class="hljs-keyword">typeof</span> options.lastOnly !== <span class="hljs-string">"undefined"</span> ) ? options.lastOnly : <span class="hljs-literal">false</span>;
        }
        <span class="hljs-keyword">if</span> ( !self._notificationListeners[ theNotification ] ) {
          <span class="hljs-built_in">console</span>.log( theNotification + <span class="hljs-string">" has not been registered."</span> );
          <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-keyword">if</span> ( self._traceNotifications ) {
          <span class="hljs-built_in">console</span>.log( <span class="hljs-string">"Notifying "</span> + self._notificationListeners[ theNotification ].length + <span class="hljs-string">" listeners for "</span> + theNotification +
            <span class="hljs-string">" ( "</span> + args + <span class="hljs-string">" ) "</span> );
        }
        <span class="hljs-keyword">var</span> async = self._notificationListeners[ theNotification ]._useAsyncNotifications,
          notifyListener = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( theListener, theNotification, args )</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
              <span class="hljs-keyword">try</span> {
                theListener.apply( self, [ self, theNotification, args ].concat( <span class="hljs-built_in">arguments</span> ) );
              } <span class="hljs-keyword">catch</span> ( err ) {
                <span class="hljs-built_in">console</span>.log( <span class="hljs-string">"WARNING"</span>, theNotification, <span class="hljs-string">"experienced an uncaught error:"</span>, err );
              }
            };
          },
          handlers = self._notificationListeners[ theNotification ].slice(); <span class="hljs-comment">// copy!</span>
        <span class="hljs-keyword">if</span> ( lastOnly &amp;&amp; handlers.length &gt; <span class="hljs-number">1</span> ) {
          handlers = [ handlers.pop() ];
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>attach * handlers</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> handler, push = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> listener <span class="hljs-keyword">in</span> self._notificationListeners ) {
          <span class="hljs-keyword">if</span> ( self._notificationListeners.hasOwnProperty( listener ) ) {
            handler = self._notificationListeners[ listener ];
            push = <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">if</span> ( listener.indexOf( <span class="hljs-string">"*"</span> ) &gt; -<span class="hljs-number">1</span> ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>candidate listener; see if it matches</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> ( listener === <span class="hljs-string">"*"</span> ) {
                push = <span class="hljs-literal">true</span>;
              } <span class="hljs-keyword">else</span>
              <span class="hljs-keyword">if</span> ( listener.substr( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ) === <span class="hljs-string">"*"</span> &amp;&amp; listener.substr( <span class="hljs-number">1</span> ) === theNotification.substr( -<span class="hljs-number">1</span> * ( listener.length - <span class="hljs-number">1</span> ) ) ) {
                push = <span class="hljs-literal">true</span>;
              } <span class="hljs-keyword">else</span>
              <span class="hljs-keyword">if</span> ( listener.substr( -<span class="hljs-number">1</span>, <span class="hljs-number">1</span> ) === <span class="hljs-string">"*"</span> &amp;&amp; listener.substr( <span class="hljs-number">0</span>, listener.length - <span class="hljs-number">1</span> ) === theNotification.substr( <span class="hljs-number">0</span>,
                listener.length - <span class="hljs-number">1</span> ) ) {
                push = <span class="hljs-literal">true</span>;
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">var</span> starPos = listener.indexOf( <span class="hljs-string">"*"</span> );
                <span class="hljs-keyword">if</span> ( listener.substr( <span class="hljs-number">0</span>, starPos ) === theNotification.substr( <span class="hljs-number">0</span>, starPos ) &amp;&amp; listener.substr( starPos + <span class="hljs-number">1</span> ) ===
                  theNotification.substr( -<span class="hljs-number">1</span> * ( listener.length - starPos - <span class="hljs-number">1</span> ) ) ) {
                  push = <span class="hljs-literal">true</span>;
                }
              }
              <span class="hljs-keyword">if</span> ( push ) {
                handler.forEach( <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( handler )</span> </span>{
                  handlers.push( handler );
                } );
              }
            }
          }
        }
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, l = handlers.length; i &lt; l; i++ ) {
          <span class="hljs-keyword">if</span> ( async ) {
            setTimeout( notifyListener( handlers[ i ], theNotification, args ), <span class="hljs-number">0</span> );
          } <span class="hljs-keyword">else</span> {
            ( notifyListener( handlers[ i ], theNotification, args ) )();
          }
        }
      }
      <span class="hljs-comment">/**
       * Notifies all listeners of a particular notification that the notification
       * has been triggered. If the notification hasn't been registered via
       * `registerNotification`, an error is logged to the console, but the function
       * itself returns silently, so be sure to watch the console for errors.
       *
       * @method notify
       * @alias emit
       * @param {String} theNotification  the notification to trigger
       * @param {*} [args]  Arguments to pass to the listener; usually an array
       */</span>
      self.notify = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( theNotification, args )</span> </span>{
        _doNotification( theNotification, {
          args: args,
          lastOnly: <span class="hljs-literal">false</span>
        } );
      };
      self.emit = self.notify;
      <span class="hljs-comment">/**
       *
       * Notifies only the most recent listener of a particular notification that
       * the notification has been triggered. If the notification hasn't been registered
       * via `registerNotification`, an error is logged to the console, but the function
       * itself returns silently.
       *
       * @method notifyMostRecent
       * @alias emitToLast
       * @param {String} theNotification  the specific notification to trigger
       * @param {*} [args]  Arguments to pass to the listener; usually an array
       */</span>
      self.notifyMostRecent = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( theNotification, args )</span> </span>{
        _doNotification( theNotification, {
          args: args,
          lastOnly: <span class="hljs-literal">true</span>
        } );
      };
      self.emitToLast = self.notifyMostRecent;
      <span class="hljs-comment">/**
       *
       * Defines a property on the object. Essentially shorthand for `Object.defineProperty`. An
       * internal `_propertyName` variable is declared which getters and setters can access.
       *
       * The property can be read-write, read-only, or write-only depending on the values in
       * `propertyOptions.read` and `propertyOptions.write`. The default is read-write.
       *
       * Getters and setters can be provided in one of two ways: they can be automatically
       * discovered by following a specific naming pattern (`getPropertyName`) if
       * `propertyOptions.selfDiscover` is `true` (the default). They can also be explicitly
       * defined by setting `propertyOptions.get` and `propertyOptions.set`.
       *
       * A property does not necessarily need a getter or setter in order to be readable or
       * writable. A basic pattern of setting or returning the private variable is implemented
       * for any property without specific getters and setters but who have indicate that the
       * property is readable or writable.
       *
       * @example
       * ```
       * self.defineProperty ( "someProperty" );        // someProperty, read-write
       * self.defineProperty ( "anotherProperty", { default: 2 } );
       * self.setWidth = function ( newWidth, oldWidth )
       * {
       *    self._width = newWidth;
       *    self.element.style.width = newWidth + "px";
       * }
       * self.defineProperty ( "width" );   // automatically discovers setWidth as the setter.
       * ```
       *
       * @method defineProperty
       * @param {String} propertyName  the name of the property; use camelCase
       * @param {Object} propertyOptions  the various options as described above.
       */</span>
      self.defineProperty = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( propertyName, propertyOptions )</span> </span>{
        <span class="hljs-keyword">var</span> options = {
          <span class="hljs-keyword">default</span>: <span class="hljs-literal">undefined</span>,
          read: <span class="hljs-literal">true</span>,
          write: <span class="hljs-literal">true</span>,
          get: <span class="hljs-literal">null</span>,
          set: <span class="hljs-literal">null</span>,
          selfDiscover: <span class="hljs-literal">true</span>,
          prefix: <span class="hljs-string">""</span>,
          configurable: <span class="hljs-literal">true</span>,
          backingVariable: <span class="hljs-literal">true</span>
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>private properties are handled differently — we want to be able to search for
_getPrivateProperty, not get_privateProperty</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> ( propertyName.substr( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ) === <span class="hljs-string">"_"</span> ) {
          options.prefix = <span class="hljs-string">"_"</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>allow other potential prefixes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> ( options.prefix !== <span class="hljs-string">""</span> ) {
          <span class="hljs-keyword">if</span> ( propertyName.substr( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ) === options.prefix ) {
            propertyName = propertyName.substr( <span class="hljs-number">1</span> );
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>merge our default options with the user options</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> property <span class="hljs-keyword">in</span> propertyOptions ) {
          <span class="hljs-keyword">if</span> ( propertyOptions.hasOwnProperty( property ) ) {
            options[ property ] = propertyOptions[ property ];
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Capital Camel Case our function names</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> fnName = propertyName.substr( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ).toUpperCase() + propertyName.substr( <span class="hljs-number">1</span> );
        <span class="hljs-keyword">var</span> getFnName = options.prefix + <span class="hljs-string">"get"</span> + fnName,
          setFnName = options.prefix + <span class="hljs-string">"set"</span> + fnName,
          _propertyName = options.prefix + <span class="hljs-string">"_"</span> + propertyName,
          _y_getFnName = options.prefix + <span class="hljs-string">"_y_get"</span> + fnName,
          _y_setFnName = options.prefix + <span class="hljs-string">"_y_set"</span> + fnName,
          _y__getFnName = options.prefix + <span class="hljs-string">"_y__get"</span> + fnName,
          _y__setFnName = options.prefix + <span class="hljs-string">"_y__set"</span> + fnName;</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>if get/set are not specified, we’ll attempt to self-discover them</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> ( options.get === <span class="hljs-literal">null</span> &amp;&amp; options.selfDiscover ) {
          <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> self[ getFnName ] === <span class="hljs-string">"function"</span> ) {
            options.get = self[ getFnName ];
          }
        }
        <span class="hljs-keyword">if</span> ( options.set === <span class="hljs-literal">null</span> &amp;&amp; options.selfDiscover ) {
          <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> self[ setFnName ] === <span class="hljs-string">"function"</span> ) {
            options.set = self[ setFnName ];
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>create the private variable</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> ( options.backingVariable ) {
          self[ _propertyName ] = options.default;
        }
        <span class="hljs-keyword">if</span> ( !options.read &amp;&amp; !options.write ) {
          <span class="hljs-keyword">return</span>; <span class="hljs-comment">// not read/write, so nothing more.</span>
        }
        <span class="hljs-keyword">var</span> defPropOptions = {
          configurable: options.configurable
        };
        <span class="hljs-keyword">if</span> ( options.read ) {
          self[ _y__getFnName ] = options.get;
          self[ _y_getFnName ] = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>if there is a getter, use it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> self[ _y__getFnName ] === <span class="hljs-string">"function"</span> ) {
              <span class="hljs-keyword">return</span> self[ _y__getFnName ]( self[ _propertyName ] );
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>otherwise return the private variable</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> self[ _propertyName ];
            }
          };
          <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> self[ getFnName ] === <span class="hljs-string">"undefined"</span> ) {
            self[ getFnName ] = self[ _y_getFnName ];
          }
          defPropOptions.get = self[ _y_getFnName ];
        }
        <span class="hljs-keyword">if</span> ( options.write ) {
          self[ _y__setFnName ] = options.set;
          self[ _y_setFnName ] = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( v )</span> </span>{
            <span class="hljs-keyword">var</span> oldV = self[ _propertyName ];
            <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> self[ _y__setFnName ] === <span class="hljs-string">"function"</span> ) {
              self[ _y__setFnName ]( v, oldV );
            } <span class="hljs-keyword">else</span> {
              self[ _propertyName ] = v;
            }
            <span class="hljs-keyword">if</span> ( oldV !== v ) {
              self.notifyDataBindingElementsForKeyPath( propertyName );
            }
          };
          <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> self[ setFnName ] === <span class="hljs-string">"undefined"</span> ) {
            self[ setFnName ] = self[ _y_setFnName ];
          }
          defPropOptions.set = self[ _y_setFnName ];
        }
        <span class="hljs-built_in">Object</span>.defineProperty( self, propertyName, defPropOptions );
      };
      <span class="hljs-comment">/**
       * Defines a custom property, which also implements a form of KVO.
       *
       * Any options not specified are defaulted in. The default is for a property
       * to be observable (which fires the default propertyNameChanged notice),
       * read/write with no custom get/set/validate routines, and no default.
       *
       * Observable Properties can have getters, setters, and validators. They can be
       * automatically discovered, assuming they follow the pattern `getObservablePropertyName`,
       * `setObservablePropertyName`, and `validateObservablePropertyName`. They can also be
       * specified explicitly by setting `propertyOptions.get`, `set`, and `validate`.
       *
       * Properties can be read-write, read-only, or write-only. This is controlled by
       * `propertyOptions.read` and `write`. The default is read-write.
       *
       * Properties can have a default value provided as well, specified by setting
       * `propertyOptions.default`.
       *
       * Finally, a notification of the form `propertyNameChanged` is fired if
       * the value changes. If the value does *not* change, the notification is not fired.
       * The name of the notification is controlled by setting `propertyOptions.notification`.
       * If you need a notification to fire when a property is simply set (regardless of the
       * change in value), set `propertyOptions.notifyAlways` to `true`.
       *
       * KVO getters, setters, and validators follow very different patterns than normal
       * property getters and setters.
       *
       * ```
       * self.getObservableWidth = function ( returnValue ) { return returnValue; };
       * self.setObservableWidth = function ( newValue, oldValue ) { return newValue; };
       * self.validateObservableWidth = function ( testValue ) { return testValue!==10; };
       * self.defineObservableProperty ( "width" );
       * ```
       *
       * @method defineObservableProperty
       * @param {String} propertyName The specific property to define
       * @param {Object} propertyOptions the options for this property.
       *
       */</span>
      self.defineObservableProperty = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( propertyName, propertyOptions )</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>set the default options and copy the specified options</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> options = {
          observable: <span class="hljs-literal">true</span>,
          notification: propertyName + <span class="hljs-string">"Changed"</span>,
          <span class="hljs-keyword">default</span>: <span class="hljs-literal">undefined</span>,
          read: <span class="hljs-literal">true</span>,
          write: <span class="hljs-literal">true</span>,
          get: <span class="hljs-literal">null</span>,
          validate: <span class="hljs-literal">null</span>,
          set: <span class="hljs-literal">null</span>,
          selfDiscover: <span class="hljs-literal">true</span>,
          notifyAlways: <span class="hljs-literal">false</span>,
          prefix: <span class="hljs-string">""</span>,
          configurable: <span class="hljs-literal">true</span>
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>private properties are handled differently — we want to be able to search for
_getPrivateProperty, not get_privateProperty</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> ( propertyName.substr( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ) === <span class="hljs-string">"_"</span> ) {
          options.prefix = <span class="hljs-string">"_"</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>allow other potential prefixes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> ( options.prefix !== <span class="hljs-string">""</span> ) {
          <span class="hljs-keyword">if</span> ( propertyName.substr( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ) === options.prefix ) {
            propertyName = propertyName.substr( <span class="hljs-number">1</span> );
          }
        }
        <span class="hljs-keyword">var</span> fnName = propertyName.substr( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ).toUpperCase() + propertyName.substr( <span class="hljs-number">1</span> );
        <span class="hljs-keyword">var</span> getObservableFnName = options.prefix + <span class="hljs-string">"getObservable"</span> + fnName,
          setObservableFnName = options.prefix + <span class="hljs-string">"setObservable"</span> + fnName,
          validateObservableFnName = options.prefix + <span class="hljs-string">"validateObservable"</span> + fnName,
          _y_propertyName = options.prefix + <span class="hljs-string">"_y_"</span> + propertyName,
          _y_getFnName = options.prefix + <span class="hljs-string">"_y_get"</span> + fnName,
          _y_setFnName = options.prefix + <span class="hljs-string">"_y_set"</span> + fnName,
          _y_validateFnName = options.prefix + <span class="hljs-string">"_y_validate"</span> + fnName,
          _y__getFnName = options.prefix + <span class="hljs-string">"_y__get"</span> + fnName,
          _y__setFnName = options.prefix + <span class="hljs-string">"_y__set"</span> + fnName,
          _y__validateFnName = options.prefix + <span class="hljs-string">"_y__validate"</span> + fnName;
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> property <span class="hljs-keyword">in</span> propertyOptions ) {
          <span class="hljs-keyword">if</span> ( propertyOptions.hasOwnProperty( property ) ) {
            options[ property ] = propertyOptions[ property ];
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>if get/set are not specified, we’ll attempt to self-discover them</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> ( options.get === <span class="hljs-literal">null</span> &amp;&amp; options.selfDiscover ) {
          <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> self[ getObservableFnName ] === <span class="hljs-string">"function"</span> ) {
            options.get = self[ getObservableFnName ];
          }
        }
        <span class="hljs-keyword">if</span> ( options.set === <span class="hljs-literal">null</span> &amp;&amp; options.selfDiscover ) {
          <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> self[ setObservableFnName ] === <span class="hljs-string">"function"</span> ) {
            options.set = self[ setObservableFnName ];
          }
        }
        <span class="hljs-keyword">if</span> ( options.validate === <span class="hljs-literal">null</span> &amp;&amp; options.selfDiscover ) {
          <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> self[ validateObservableFnName ] === <span class="hljs-string">"function"</span> ) {
            options.validate = self[ validateObservableFnName ];
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>if the property is observable, register its notification</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> ( options.observable ) {
          self.registerNotification( options.notification );
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>create the private variable; <em>_ here to avoid self-defined </em></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        self[ _y_propertyName ] = options.default;
        <span class="hljs-keyword">if</span> ( !options.read &amp;&amp; !options.write ) {
          <span class="hljs-keyword">return</span>; <span class="hljs-comment">// not read/write, so nothing more.</span>
        }
        <span class="hljs-keyword">var</span> defPropOptions = {
          configurable: <span class="hljs-literal">true</span>
        };
        <span class="hljs-keyword">if</span> ( options.read ) {
          self[ _y__getFnName ] = options.get;
          self[ _y_getFnName ] = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>if there is a getter, use it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> self[ _y__getFnName ] === <span class="hljs-string">"function"</span> ) {
              <span class="hljs-keyword">return</span> self[ _y__getFnName ]( self[ _y_propertyName ] );
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>otherwise return the private variable</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> self[ _y_propertyName ];
            }
          };
          defPropOptions.get = self[ _y_getFnName ];
        }
        <span class="hljs-keyword">if</span> ( options.write ) {
          self[ _y__validateFnName ] = options.validate;
          self[ _y__setFnName ] = options.set;
          self[ _y_setFnName ] = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( v )</span> </span>{
            <span class="hljs-keyword">var</span> oldV = self[ _y_propertyName ],
              valid = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> self[ _y__validateFnName ] === <span class="hljs-string">"function"</span> ) {
              valid = self[ _y__validateFnName ]( v );
            }
            <span class="hljs-keyword">if</span> ( valid ) {
              <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> self[ _y__setFnName ] === <span class="hljs-string">"function"</span> ) {
                self[ _y_propertyName ] = self[ _y__setFnName ]( v, oldV );
              } <span class="hljs-keyword">else</span> {
                self[ _y_propertyName ] = v;
              }
              <span class="hljs-keyword">if</span> ( oldV !== v ) {
                self.notifyDataBindingElementsForKeyPath( propertyName );
              }
              <span class="hljs-keyword">if</span> ( v !== oldV || options.notifyAlways ) {
                <span class="hljs-keyword">if</span> ( options.observable ) {
                  self.notify( options.notification, {
                    <span class="hljs-string">"new"</span>: v,
                    <span class="hljs-string">"old"</span>: oldV
                  } );
                }
              }
            }
          };
          defPropOptions.set = self[ _y_setFnName ];
        }
        <span class="hljs-built_in">Object</span>.defineProperty( self, propertyName, defPropOptions );
      };
      <span class="hljs-comment">/*
       * data binding support
       */</span>
      self._dataBindings = [];
      <span class="hljs-comment">/**
       * Configure a data binding to an HTML element (el) for
       * a particular property (keyPath). Returns self for chaining.
       *
       * @method dataBindOn
       * @param  {Node}   el      the DOM element to bind to; must support the change event
       * @param  {string} keyPath the property to observe (shallow only; doesn't follow dots.)
       * @return {*}              self; chain away!
       */</span>
      self.dataBindOn = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dataBindOn</span><span class="hljs-params">( el, keyPath )</span> </span>{
        <span class="hljs-keyword">if</span> ( self._dataBindings[ keyPath ] === <span class="hljs-literal">undefined</span> ) {
          self._dataBindings[ keyPath ] = [];
        }
        self._dataBindings[ keyPath ].push( el );
        el.setAttribute( <span class="hljs-string">"data-y-keyPath"</span>, keyPath );
        el.addEventListener( <span class="hljs-string">"change"</span>, self.updatePropertyForKeyPath, <span class="hljs-literal">false</span> );
        <span class="hljs-keyword">return</span> self;
      };
      <span class="hljs-comment">/**
       * Turn off data binding for a particular element and
       * keypath.
       *
       * @method dataBindOff
       * @param  {Node}   el      element to remove data binding from
       * @param  {string} keyPath keypath to stop observing
       * @return {*}              self; chain away!
       */</span>
      self.dataBindOff = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dataBindOff</span><span class="hljs-params">( el, keyPath )</span> </span>{
        <span class="hljs-keyword">var</span> keyPathEls = self._dataBindings[ keyPath ],
          elPos;
        <span class="hljs-keyword">if</span> ( keyPathEls !== <span class="hljs-literal">undefined</span> ) {
          elPos = keyPathEls.indexOf( el );
          <span class="hljs-keyword">if</span> ( elPos &gt; -<span class="hljs-number">1</span> ) {
            keyPathEls.splice( elPos, <span class="hljs-number">1</span> );
            el.removeAttribute( <span class="hljs-string">"data-y-keyPath"</span> );
            el.removeEventListener( <span class="hljs-string">"change"</span>, self.updatePropertyForKeyPath );
          }
        }
        <span class="hljs-keyword">return</span> self;
      };
      <span class="hljs-comment">/**
       * Remove all data bindings for a given property
       *
       * @method dataBindAllOffForKeyPath
       * @param  {String} keyPath keypath to stop observing
       * @return {*}              self; chain away
       */</span>
      self.dataBindAllOffForKeyPath = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dataBindAllOffForKeyPath</span><span class="hljs-params">( keyPath )</span> </span>{
        <span class="hljs-keyword">var</span> keyPathEls = self._dataBindings[ keyPath ];
        <span class="hljs-keyword">if</span> ( keyPathEls !== <span class="hljs-literal">undefined</span> ) {
          keyPathEls.forEach( <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( el )</span> </span>{
            el.removeAttribute( <span class="hljs-string">"data-y-keyPath"</span> );
            el.removeEventListener( <span class="hljs-string">"change"</span>, self.updatePropertyForKeyPath );
          } );
          keyPathEls = [];
        }
        <span class="hljs-keyword">return</span> self;
      };
      <span class="hljs-comment">/**
       * Remove all data bindings for this object
       *
       * @method dataBindAllOff
       * @return {*}  self
       */</span>
      self.dataBindAllOff = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dataBindAllOff</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> keyPath <span class="hljs-keyword">in</span> self._dataBindings ) {
          <span class="hljs-keyword">if</span> ( self._dataBindings.hasOwnProperty( keyPath ) ) {
            self.dataBindAllOffForKeyPath( keyPath );
          }
        }
      };
      <span class="hljs-comment">/**
       * Update a property on this object based on the
       * keyPath and value. If called as an event handler, `this` refers to the
       * triggering element, and keyPath is on `data-y-keyPath` attribute.
       *
       * @method updatePropertyForKeyPath
       * @param  {String} keyPath property to set
       * @param  {*} value        value to set
       */</span>
      self.updatePropertyForKeyPath = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updatePropertyForKeyPath</span><span class="hljs-params">( keyPath, value )</span> </span>{
        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span> !== self &amp;&amp; <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Node ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>we’ve been called from an event handler</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            self[ <span class="hljs-keyword">this</span>.getAttribute( <span class="hljs-string">"data-y-keyPath"</span> ) ] = <span class="hljs-keyword">this</span>.value;
            <span class="hljs-keyword">return</span>;
          }
          self[ keyPath ] = value;
        } <span class="hljs-keyword">catch</span> ( err ) {
          <span class="hljs-built_in">console</span>.log( <span class="hljs-string">"Failed to update"</span>, keyPath, <span class="hljs-string">"with"</span>, value );
        }
      };
      <span class="hljs-comment">/**
       * notify all elements attached to a
       * key path that the source value has changed. Called by all properties created
       * with defineProperty and defineObservableProperty.
       *
       * @method @notifyDataBindingElementsForKeyPath
       * @param  {String} keyPath keypath of elements to notify
       */</span>
      self.notifyDataBindingElementsForKeyPath = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">notifyDataBindingElementsForKeyPath</span><span class="hljs-params">( keyPath )</span> </span>{
        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">var</span> keyPathEls = self._dataBindings[ keyPath ],
            el;
          <span class="hljs-keyword">if</span> ( keyPathEls !== <span class="hljs-literal">undefined</span> ) {
            <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, l = keyPathEls.length; i &lt; l; i++ ) {
              el = keyPathEls[ i ];
              <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> el.value !== <span class="hljs-string">"undefined"</span> ) {
                el.value = self[ keyPath ];
              } <span class="hljs-keyword">else</span>
              <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> el.textContent !== <span class="hljs-string">"undefined"</span> ) {
                el.textContent = self[ keyPath ];
              } <span class="hljs-keyword">else</span>
              <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> el.innerText !== <span class="hljs-string">"undefined"</span> ) {
                el.innerText = self[ keyPath ];
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-built_in">console</span>.log( <span class="hljs-string">"Data bind failure; browser doesn't understand value, textContent, or innerText."</span> );
              }
            }
          }
        } <span class="hljs-keyword">catch</span> ( err ) {
          <span class="hljs-built_in">console</span>.log( <span class="hljs-string">"Failed to update elements for "</span>, keyPath );
        }
      };
      <span class="hljs-comment">/**
       * Auto initializes the object based on the arguments passed to the object constructor. Any object
       * that desires to be auto-initializable must perform the following prior to returning themselves:
       *
       * ```
       * self._autoInit.apply (self, arguments);
       * ```
       *
       * Each init must call the super of init, and each init must return self.
       *
       * If the first parameter to _autoInit (and thus to the object constructor) is an object,
       * initWithOptions is called if it exists. Otherwise init is called with all the arguments.
       *
       * If NO arguments are passed to the constructor (and thus to this method), then no
       * auto initialization is performed. If one desires an auto-init on an object that requires
       * no parameters, pass a dummy parameter to ensure init will be called
       *
       * @method _autoInit
       * @returns {*}
       */</span>
      self._autoInit = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">0</span> ) {
          <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">arguments</span>.length === <span class="hljs-number">1</span> ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>chances are this is an initWithOptions, but make sure the incoming parameter is an object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">arguments</span>[ <span class="hljs-number">0</span> ] === <span class="hljs-string">"object"</span> ) {
              <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> self.initWithOptions !== <span class="hljs-string">"undefined"</span> ) {
                <span class="hljs-keyword">return</span> self.initWithOptions.apply( self, <span class="hljs-built_in">arguments</span> );
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> self.init.apply( self, <span class="hljs-built_in">arguments</span> );
              }
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> self.init.apply( self, <span class="hljs-built_in">arguments</span> );
            }
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> self.init.apply( self, <span class="hljs-built_in">arguments</span> );
          }
        }
      };
      <span class="hljs-comment">/**
       *
       * Readies an object to be destroyed. The base object only clears the notifications and
       * the attached listeners.
       * @method destroy
       */</span>
      self.destroy = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>clear data bindings</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        self.dataBindAllOff();</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>clear any listeners.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        self._notificationListeners = {};
        self._tagListeners = {};
        self._constructObjectCategories( BaseObject.ON_DESTROY_CATEGORY );</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>ready to be destroyed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      };</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>self-categorize</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      self._constructObjectCategories();</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>call auto init</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      self._autoInit.apply( self, <span class="hljs-built_in">arguments</span> );</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>done</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> self;
    };
  <span class="hljs-comment">/**
   * Promotes a non-BaseObject into a BaseObject by copying all its methods to
   * the new object and copying all its properties as observable properties.
   *
   * @method promote
   * @param  {*} nonBaseObject The non-BaseObject to promote
   * @return {BaseObject}               BaseObject
   */</span>
  BaseObject.promote = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">promote</span><span class="hljs-params">( nonBaseObject )</span> </span>{
    <span class="hljs-keyword">var</span> newBaseObject, theProp;
    <span class="hljs-keyword">if</span> ( nonBaseObject !== <span class="hljs-literal">undefined</span> ) {
      newBaseObject = <span class="hljs-keyword">new</span> BaseObject();
      <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> prop <span class="hljs-keyword">in</span> nonBaseObject ) {
        <span class="hljs-keyword">if</span> ( nonBaseObject.hasOwnProperty( prop ) ) {
          theProp = nonBaseObject[ prop ];
          <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> theProp === <span class="hljs-string">"function"</span> ) {
            newBaseObject[ prop ] = theProp;
          } <span class="hljs-keyword">else</span> {
            newBaseObject.defineObservableProperty( prop, {
              <span class="hljs-keyword">default</span>: theProp
            } );
          }
        }
      }
    }
    <span class="hljs-keyword">return</span> newBaseObject;
  };
  <span class="hljs-comment">/**
   * Object categories. Of the form:
   *
   * ```
   * { className: [ constructor1, constructor2, ... ], ... }
   * ```
   *
   * Global to the app and library. BaseObject's init() method will call each category in the class hierarchy.
   *
   * @property _objectCategories
   * @type {{}}
   * @private
   */</span>
  BaseObject._objectCategories = [ {}, {}, {} ];
  BaseObject.ON_CREATE_CATEGORY = <span class="hljs-number">0</span>;
  BaseObject.ON_INIT_CATEGORY = <span class="hljs-number">1</span>;
  BaseObject.ON_DESTROY_CATEGORY = <span class="hljs-number">2</span>;
  <span class="hljs-comment">/**
   * Register a category constructor for a specific class. The function must take `self` as a parameter, and must
   * not assume the presence of any other category
   *
   * The options parameter takes the form:
   *
   * ```
   * { class: class name to register for
   *   method: constructor method
   *   priority: ON_CREATE_CATEGORY or ON_INIT_CATEGORY
   * }
   * ```
   *
   * @method registerCategoryConstructor
   * @param {Object} options
   */</span>
  BaseObject.registerCategoryConstructor = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">registerCategoryConstructor</span><span class="hljs-params">( options )</span> </span>{
    <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> options === <span class="hljs-string">"undefined"</span> ) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>( <span class="hljs-string">"registerCategoryConstructor requires a class name and a constructor method."</span> );
    }
    <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> options.class !== <span class="hljs-string">"undefined"</span> ) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>( <span class="hljs-string">"registerCategoryConstructor requires options.class"</span> );
    }
    <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> options.method !== <span class="hljs-string">"undefined"</span> ) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>( <span class="hljs-string">"registerCategoryConstructor requires options.method"</span> );
    }
    <span class="hljs-keyword">var</span> className = options.class;
    <span class="hljs-keyword">var</span> method = options.method;
    <span class="hljs-keyword">var</span> priority = BaseObject.ON_CREATE_CATEGORY;
    <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> options.priority !== <span class="hljs-string">"undefined"</span> ) {
      priority = options.priority;
    }
    <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> BaseObject._objectCategories[ priority ][ className ] === <span class="hljs-string">"undefined"</span> ) {
      BaseObject._objectCategories[ priority ][ className ] = [];
    }
    BaseObject._objectCategories[ priority ][ className ].push( method );
  };
  BaseObject.meta = {
    version: <span class="hljs-string">"00.05.101"</span>,
    <span class="hljs-keyword">class</span>: _className,
    autoInitializable: <span class="hljs-literal">true</span>,
    categorizable: <span class="hljs-literal">true</span>
  };
  <span class="hljs-keyword">return</span> BaseObject;
} );</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
