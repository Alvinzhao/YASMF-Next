<!DOCTYPE html><html lang="en"><head><title>util/object</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../"><meta name="groc-document-path" content="util/object"><meta name="groc-project-path" content="lib/yasmf/util/object.js"><link rel="stylesheet" type="text/css" media="all" href="../assets/style.css"><script type="text/javascript" src="../assets/behavior.js"></script><body><div id="meta"><div class="file-path">lib/yasmf/util/object.js</div></div><div id="document"><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'>Module object.js author Kerri Shotts and version 0.5
<code>Copyright (c) 2013 Kerri Shotts, photoKandy Studios LLC
Permission is hereby granted, free of charge, to any person obtaining a copy of this
software and associated documentation files (the &quot;Software&quot;), to deal in the Software
without restriction, including without limitation the rights to use, copy, modify,
merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to the following
conditions:
The above copyright notice and this permission notice shall be included in all copies
or substantial portions of the Software.
THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.</code></span></p>
<h1 id="base-object">Base Object</h1></div></div><div class="code"><div class="wrapper"><span class="hljs-comment">/*global define, console, setTimeout*/</span>
define( <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">var</span> _className = <span class="hljs-string">"BaseObject"</span>,</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'> class BaseObject</span></p>
<p>BaseObject is the base object for all complex objects used by YASMF;
simpler objects that are properties-only do not inherit from this
class.</p>
<p>BaseObject provides simple inheritance, but not by using the typical
prototypal method. Rather inheritance is formed by object composition
where all objects are instances of BaseObject with methods overridden
instead. As such, you can <em>not</em> use any Javascript type checking to
differentiate PKObjects; you should instead use the <code>class</code>
property.</p>
<p>BaseObject provides inheritance to more than just a constructor: any
method can be overridden, but it is critical that the super-chain
be properly initialized. See the <code>super</code> and <code>overrideSuper</code>
methods for more information.</p></div></div><div class="code"><div class="wrapper">    BaseObject = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;</div></div></div><div class="segment"><div class="comments doc-section doc-section-private"><div class="wrapper"><p><span class='doc-section-header'>Private property <em>classHierarchy of type _Array</em> and default [&quot;BaseObject&quot;]</span></p>
<p>We need a way to provide inheritance. Most methods only provide
inheritance across the constructor chain, not across any possible
method. But for our purposes, we need to be able to provide for
overriding any method (such as drawing, touch responses, etc.),
and so we implement inheritance in a different way.</p>
<p>First, the _classHierarchy, a private property, provides the
inheritance tree. All objects inherit from &quot;BaseObject&quot;.</p></div></div><div class="code"><div class="wrapper">      self._classHierarchy = [ _className ];</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'>Method subclass</span></p>
<p>Objects are subclassed using this method. The newClass is the
unique class name of the object (and should match the class&#39;
actual name.</p>
<p>Parameters:</p>
<ul>
<li><strong>newClass must be a String.</strong><br/>(- the new unique class of the object)</li>
</ul></div></div><div class="code"><div class="wrapper">      self.subclass = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( newClass )</span> </span>{
        self._classHierarchy.push( newClass );
      };</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'>Method getClass</span></p>
<p>getClass returns the current class of the object. The
<code>class</code> property can be used as well. Note that there
is no <code>setter</code> for this property; an object&#39;s class
can <em>not</em> be changed.</p>
<p><strong>Returns a String</strong><br/>(the class of the instance)</p></div></div><div class="code"><div class="wrapper">      self.getClass = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> self._classHierarchy[ self._classHierarchy.length - <span class="hljs-number">1</span> ];
      };</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'>Property class readOnly and of type <em>String</em></span></p>
<p>The class of the instance. <strong>Read-only</strong></p></div></div><div class="code"><div class="wrapper">      <span class="hljs-built_in">Object</span>.defineProperty( self, <span class="hljs-string">"class"</span>, {
        get: self.getClass,
        configurable: <span class="hljs-literal">false</span>
      } );</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'>Method getSuperClassOfClass</span></p>
<p>Returns the super class for the given class. If the
class is not supplied, the class is assumed to be the
object&#39;s own class.</p>
<p>The property &quot;superClass&quot; uses this to return the
object&#39;s direct superclass, but getSuperClassOfClass
can be used to determine superclasses higher up
the hierarchy.</p>
<p>Parameters:</p>
<ul>
<li><strong>aClass is optional, must be a String, and has a default value of currentClass.</strong><br/>(the class for which you want the super class. If not specified, the instance&#39;s class is used.)</li>
</ul>
<p><strong>Returns a String</strong><br/>(the super-class of the specified class.)</p></div></div><div class="code"><div class="wrapper">      self.getSuperClassOfClass = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( aClass )</span> </span>{
        <span class="hljs-keyword">var</span> theClass = aClass || self.class;
        <span class="hljs-keyword">var</span> i = self._classHierarchy.indexOf( theClass );
        <span class="hljs-keyword">if</span> ( i &gt; -<span class="hljs-number">1</span> ) {
          <span class="hljs-keyword">return</span> self._classHierarchy[ i - <span class="hljs-number">1</span> ];
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }
      };</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'>Property superClass of type <em>String</em></span></p>
<p>The superclass of the instance.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-built_in">Object</span>.defineProperty( self, <span class="hljs-string">"superClass"</span>, {
        get: self.getSuperClassOfClass,
        configurable: <span class="hljs-literal">false</span>
      } );</div></div></div><div class="segment"><div class="comments doc-section doc-section-private"><div class="wrapper"><p><span class='doc-section-header'>Private property <em>super of type _Object</em></span></p>
<p>_super is an object that stores overridden functions by class and method
name. This is how we get the ability to arbitrarily override any method
already present in the superclass.</p></div></div><div class="code"><div class="wrapper">      self._super = {};</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'>Method overrideSuper</span></p>
<p>Must be called prior to defining the overridden function as this moves
the original function into the _super object. The functionName must
match the name of the method exactly, since there may be a long tree
of code that depends on it.</p>
<p>Parameters:</p>
<ul>
<li><p><strong>theClass must be a String.</strong><br/>(the class for which the function override is desired)</p>
</li>
<li><p><strong>theFunctionName must be a String.</strong><br/>(the name of the function to override)</p>
</li>
<li><p><strong>theActualFunction must be a Function.</strong><br/>(the actual function (or pointer to function))</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">      self.overrideSuper = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( theClass, theFunctionName, theActualFunction )</span> </span>{
        <span class="hljs-keyword">var</span> superClass = self.getSuperClassOfClass( theClass );
        <span class="hljs-keyword">if</span> ( !self._super[ superClass ] ) {
          self._super[ superClass ] = {};
        }
        self._super[ superClass ][ theFunctionName ] = theActualFunction;
      };</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'>Method override</span></p>
<p>Parameters:</p>
<ul>
<li><strong>theNewFunction must be a Function.</strong><br/>(- The function to override. Must have the name of the overriding function.)</li>
</ul>
<p>Example:</p>
<pre><code>obj.override ( function initWithOptions ( options )
    { ... } );</code></pre></div></div><div class="code"><div class="wrapper">      self.override = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( theNewFunction )</span> </span>{
        <span class="hljs-keyword">var</span> theFunctionName = theNewFunction.name;
        <span class="hljs-keyword">if</span> ( theFunctionName !== <span class="hljs-string">""</span> ) {
          self.overrideSuper( self.class, theFunctionName, self[ theFunctionName ] );
          self[ theFunctionName ] = theNewFunction;
        }
      };</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'>Method super</span></p>
<p>Calls a super function with any number of arguments.</p>
<p>Parameters:</p>
<ul>
<li><p><strong>theClass must be a String.</strong><br/>(the current class instance)</p>
</li>
<li><p><strong>theFunctionName must be a String.</strong><br/>(the name of the function to execute)</p>
</li>
<li><p><strong>args is optional and must be an Array.</strong><br/>(Any number of parameters to pass to the super method)</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">      self.super = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( theClass, theFunctionName, args )</span> </span>{
        <span class="hljs-keyword">var</span> superClass = self.getSuperClassOfClass( theClass );
        <span class="hljs-keyword">if</span> ( self._super[ superClass ] ) {
          <span class="hljs-keyword">if</span> ( self._super[ superClass ][ theFunctionName ] ) {
            <span class="hljs-keyword">return</span> self._super[ superClass ][ theFunctionName ].apply( self, args );
          }
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      };</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'>Method _constructObjectCategories</span></p>
<p>Category support; for an object to get category support for their class,
they must call this method prior to any auto initialization</p></div></div><div class="code"><div class="wrapper">      self._constructObjectCategories = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_constructObjectCategories</span><span class="hljs-params">( pri )</span> </span>{
        <span class="hljs-keyword">var</span> priority = BaseObject.ON_CREATE_CATEGORY;
        <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> pri !== <span class="hljs-string">"undefined"</span> ) {
          priority = pri;
        }
        <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> BaseObject._objectCategories[ priority ][ self.class ] !== <span class="hljs-string">"undefined"</span> ) {
          BaseObject._objectCategories[ priority ][ self.class ].forEach( <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( categoryConstructor )</span> </span>{
            <span class="hljs-keyword">try</span> {
              categoryConstructor( self );
            } <span class="hljs-keyword">catch</span> ( e ) {
              <span class="hljs-built_in">console</span>.log( <span class="hljs-string">"Error during category construction: "</span> + e.message );
            }
          } );
        }
      };</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'>Method init</span></p>
<p>initializes the object</p></div></div><div class="code"><div class="wrapper">      self.init = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        self._constructObjectCategories( BaseObject.ON_INIT_CATEGORY );
        <span class="hljs-keyword">return</span> self;
      };</div></div></div><div class="segment"><div class="comments doc-section doc-section-private"><div class="wrapper"><p><span class='doc-section-header'>Private property <em>tag of type _Object</em></span></p>
<p>Objects have some properties that we want all objects to have...</p>
<p>Stores the values of all the tags associated with the instance.</p></div></div><div class="code"><div class="wrapper">      self._tags = {};</div></div></div><div class="segment"><div class="comments doc-section doc-section-private"><div class="wrapper"><p><span class='doc-section-header'>Private property <em>tagListeners of type _Object</em></span></p>
<p>Stores the <em>listeners</em> for all the tags associated with the instance.</p></div></div><div class="code"><div class="wrapper">      self._tagListeners = {};</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'>Method setTagForKey</span></p>
<p>Sets the value for a specific tag associated with the instance. If the
tag does not exist, it is created.</p>
<p>Any listeners attached to the tag via <code>addTagListenerForKey</code> will be
notified of the change. Listeners are passed three parameters:
<code>self</code> (the originating instance),
<code>theKey</code> (the tag being changed),
and <code>theValue</code> (the value of the tag); the tag is <em>already</em> changed</p>
<p>Parameters:</p>
<ul>
<li><p><strong>theKey must be a *.</strong><br/>(the name of the tag; &quot;__default&quot; is special and refers to the default tag visible via the <code>tag</code> property.)</p>
</li>
<li><p><strong>theValue must be a *.</strong><br/>(the value to assign to the tag.)</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">      self.setTagForKey = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( theKey, theValue )</span> </span>{
        self._tags[ theKey ] = theValue;
        <span class="hljs-keyword">var</span> notifyListener = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( theListener, theKey, theValue )</span> </span>{
          <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            theListener( self, theKey, theValue );
          };
        };
        <span class="hljs-keyword">if</span> ( self._tagListeners[ theKey ] ) {
          <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; self._tagListeners[ theKey ].length; i++ ) {
            setTimeout( notifyListener( self._tagListeners[ theKey ][ i ], theKey, theValue ), <span class="hljs-number">0</span> );
          }
        }
      };</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'>Method getTagForKey</span></p>
<p>Returns the value for a given key. If the key does not exist, the
result is undefined.</p>
<p>Parameters:</p>
<ul>
<li><strong>theKey must be a *.</strong><br/>(the tag; &quot;__default&quot; is special and refers to the default tag visible via the <code>tag</code> property.)</li>
</ul>
<p><strong>Returns a *</strong><br/>(the value of the key)</p></div></div><div class="code"><div class="wrapper">      self.getTagForKey = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( theKey )</span> </span>{
        <span class="hljs-keyword">return</span> self._tags[ theKey ];
      };</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'>Method addListenerForKey</span></p>
<p>Add a listener to a specific tag. The listener will receive three
parameters whenever the tag changes (though they are optional). The tag
itself doesn&#39;t need to exist in order to assign a listener to it.</p>
<p>The first parameter is the object for which the tag has been changed.
The second parameter is the tag being changed, and the third parameter
is the value of the tag. <strong>Note:</strong> the value has already changed by
the time the listener is called.</p>
<p>Parameters:</p>
<ul>
<li><p><strong>theKey must be a *.</strong><br/>(The tag for which to add a listener; <code>__default</code> is special and refers the default tag visible via the <code>tag</code> property.)</p>
</li>
<li><p><strong>theListener must be a Function.</strong><br/>(the function (or reference) to call when the value changes.)</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">      self.addTagListenerForKey = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( theKey, theListener )</span> </span>{
        <span class="hljs-keyword">if</span> ( !self._tagListeners[ theKey ] ) {
          self._tagListeners[ theKey ] = [];
        }
        self._tagListeners[ theKey ].push( theListener );
      };</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'>Method removeTagListenerForKey</span></p>
<p>Removes a listener from being notified when a tag changes.</p>
<p>Parameters:</p>
<ul>
<li><p><strong>theKey must be a *.</strong><br/>(the tag from which to remove the listener; <code>__default</code> is special and refers to the default tag visible via the <code>tag</code> property.)</p>
</li>
<li><p><strong>theListener must be a Function.</strong><br/>(the function (or reference) to remove.)</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">      self.removeTagListenerForKey = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( theKey, theListener )</span> </span>{
        <span class="hljs-keyword">if</span> ( !self._tagListeners[ theKey ] ) {
          self._tagListeners[ theKey ] = [];
        }
        <span class="hljs-keyword">var</span> i = self._tagListeners[ theKey ].indexOf( theListener );
        <span class="hljs-keyword">if</span> ( i &gt; -<span class="hljs-number">1</span> ) {
          self._tagListeners[ theKey ].splice( i, <span class="hljs-number">1</span> );
        }
      };</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'>Method setTag</span></p>
<p>Sets the value for the simple tag (<code>__default</code>). Any listeners attached
to <code>__default</code> will be notified.</p>
<p>Parameters:</p>
<ul>
<li><strong>theValue must be a *.</strong><br/>(the value for the tag)</li>
</ul></div></div><div class="code"><div class="wrapper">      self.setTag = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( theValue )</span> </span>{
        self.setTagForKey( <span class="hljs-string">"__default"</span>, theValue );
      };</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'>Method getTag</span></p>
<p>Returns the value for the given tag (<code>__default</code>). If the tag has never been
set, the result is undefined.</p>
<p><strong>Returns a *</strong><br/>(the value of the tag.)</p></div></div><div class="code"><div class="wrapper">      self.getTag = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> self.getTagForKey( <span class="hljs-string">"__default"</span> );
      };</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'>Property tag of type <em>*</em></span></p>
<p>The default tag for the instance. Changing the tag itself (not any sub-properties of an object)
will notify any listeners attached to <code>__default</code>.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-built_in">Object</span>.defineProperty( self, <span class="hljs-string">"tag"</span>, {
        get: self.getTag,
        set: self.setTag,
        configurable: <span class="hljs-literal">true</span>
      } );</div></div></div><div class="segment"><div class="comments doc-section doc-section-private"><div class="wrapper"><p><span class='doc-section-header'>Private property <em>notificationListeners of type _Object</em></span></p>
<p>All objects subject notifications for events</p>
<p>Supports notification listeners.</p></div></div><div class="code"><div class="wrapper">      self._notificationListeners = {};</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'>Method addListenerForNotification is aliased as on</span></p>
<p>Adds a listener for a notification. If a notification has not been
registered (via <code>registerNotification</code>), an error is logged on the console
and the function returns without attaching the listener. This means if
you aren&#39;t watching the console, the function fails nearly silently.</p>
<blockquote>
<p>By default, no notifications are registered.</p>
</blockquote>
<p>If the first parameter is an object, multiple listeners can be registered:
{ &quot;viewWillAppear&quot;: handler, &quot;viewDidAppear&quot;: handler2}.</p>
<p>Parameters:</p>
<ul>
<li><p><strong>theNotification can be a String or a *.</strong><br/>(the name of the notification)</p>
</li>
<li><p><strong>theListener must be a Function.</strong><br/>(the function (or reference) to be called when the notification is triggered.)</p>
</li>
</ul>
<p><strong>Returns a *</strong><br/>(returns self for chaining)</p></div></div><div class="code"><div class="wrapper">      self.addListenerForNotification = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( theNotification, theListener, async )</span> </span>{
        <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> theNotification === <span class="hljs-string">"object"</span> ) {
          <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> n <span class="hljs-keyword">in</span> theNotification ) {
            <span class="hljs-keyword">if</span> ( theNotification.hasOwnProperty( n ) ) {
              self.addListenerForNotification( n, theNotification[ n ], theListener ); <span class="hljs-comment">// async would shift up</span>
            }
          }
          <span class="hljs-keyword">return</span> self;
        }
        <span class="hljs-keyword">if</span> ( !self._notificationListeners[ theNotification ] ) {
          self.registerNotification( theNotification, ( <span class="hljs-keyword">typeof</span> async !== <span class="hljs-string">"undefined"</span> ) ? async : <span class="hljs-literal">false</span> );
        }
        self._notificationListeners[ theNotification ].push( theListener );
        <span class="hljs-keyword">if</span> ( self._traceNotifications ) {
          <span class="hljs-built_in">console</span>.log( <span class="hljs-string">"Adding listener "</span> + theListener + <span class="hljs-string">" for notification "</span> + theNotification );
        }
        <span class="hljs-keyword">return</span> self;
      };
      self.on = self.addListenerForNotification;</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'>Method removeListenerForNotification is aliased as off</span></p>
<p>Removes a listener from a notification. If a notification has not been
registered (via <code>registerNotification</code>), an error is logged on the console
and the function returns without attaching the listener. This means if
you aren&#39;t watching the console, the function fails nearly silently.</p>
<blockquote>
<p>By default, no notifications are registered.</p>
</blockquote>
<p>Parameters:</p>
<ul>
<li><p><strong>theNotification must be a String.</strong><br/>(the notification)</p>
</li>
<li><p><strong>theListener must be a Function.</strong><br/>(The function or reference to remove)</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">      self.removeListenerForNotification = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( theNotification, theListener )</span> </span>{
        <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> theNotification === <span class="hljs-string">"object"</span> ) {
          <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> n <span class="hljs-keyword">in</span> theNotification ) {
            <span class="hljs-keyword">if</span> ( theNotification.hasOwnProperty( n ) ) {
              self.removeListenerForNotification( n, theNotification[ n ] );
            }
          }
          <span class="hljs-keyword">return</span> self;
        }
        <span class="hljs-keyword">if</span> ( !self._notificationListeners[ theNotification ] ) {
          <span class="hljs-built_in">console</span>.log( theNotification + <span class="hljs-string">" has not been registered."</span> );
          <span class="hljs-keyword">return</span> self;
        }
        <span class="hljs-keyword">var</span> i = self._notificationListeners[ theNotification ].indexOf( theListener );
        <span class="hljs-keyword">if</span> ( self._traceNotifications ) {
          <span class="hljs-built_in">console</span>.log( <span class="hljs-string">"Removing listener "</span> + theListener + <span class="hljs-string">" (index: "</span> + i + <span class="hljs-string">") from  notification "</span> + theNotification );
        }
        <span class="hljs-keyword">if</span> ( i &gt; -<span class="hljs-number">1</span> ) {
          self._notificationListeners[ theNotification ].splice( i, <span class="hljs-number">1</span> );
        }
        <span class="hljs-keyword">return</span> self;
      };
      self.off = self.removeListenerForNotification;</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'>Method registerNotification</span></p>
<p>Registers a notification so that listeners can then be attached. Notifications
should be registered as soon as possible, otherwise listeners may attempt to
attach to a notification that isn&#39;t registered.</p>
<p>Parameters:</p>
<ul>
<li><p><strong>theNotification must be a String.</strong><br/>(the name of the notification.)</p>
</li>
<li><p><strong>async must be a Boolean.</strong><br/>(if true, notifications are sent wrapped in setTimeout)</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">      self.registerNotification = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( theNotification, async )</span> </span>{
        <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> self._notificationListeners[ theNotification ] === <span class="hljs-string">"undefined"</span> ) {
          self._notificationListeners[ theNotification ] = [];
          self._notificationListeners[ theNotification ]._useAsyncNotifications = ( <span class="hljs-keyword">typeof</span> async !== <span class="hljs-string">"undefined"</span> ? async : <span class="hljs-literal">true</span> );
        }
        <span class="hljs-keyword">if</span> ( self._traceNotifications ) {
          <span class="hljs-built_in">console</span>.log( <span class="hljs-string">"Registering notification "</span> + theNotification );
        }
      };
      self._traceNotifications = <span class="hljs-literal">false</span>;

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_doNotification</span><span class="hljs-params">( theNotification, options )</span> </span>{
        <span class="hljs-keyword">var</span> args,
          lastOnly = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> options !== <span class="hljs-string">"undefined"</span> ) {
          args = ( <span class="hljs-keyword">typeof</span> options.args !== <span class="hljs-string">"undefined"</span> ) ? options.args : <span class="hljs-literal">undefined</span>;
          lastOnly = ( <span class="hljs-keyword">typeof</span> options.lastOnly !== <span class="hljs-string">"undefined"</span> ) ? options.lastOnly : <span class="hljs-literal">false</span>;
        }
        <span class="hljs-keyword">if</span> ( !self._notificationListeners[ theNotification ] ) {
          <span class="hljs-built_in">console</span>.log( theNotification + <span class="hljs-string">" has not been registered."</span> );
          <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-keyword">if</span> ( self._traceNotifications ) {
          <span class="hljs-built_in">console</span>.log( <span class="hljs-string">"Notifying "</span> + self._notificationListeners[ theNotification ].length + <span class="hljs-string">" listeners for "</span> + theNotification +
            <span class="hljs-string">" ( "</span> + args + <span class="hljs-string">" ) "</span> );
        }
        <span class="hljs-keyword">var</span> async = self._notificationListeners[ theNotification ]._useAsyncNotifications,
          notifyListener = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( theListener, theNotification, args )</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
              <span class="hljs-keyword">try</span> {
                theListener.apply( self, [ self, theNotification, args ].concat( <span class="hljs-built_in">arguments</span> ) );
              } <span class="hljs-keyword">catch</span> ( err ) {
                <span class="hljs-built_in">console</span>.log( <span class="hljs-string">"WARNING"</span>, theNotification, <span class="hljs-string">"experienced an uncaught error:"</span>, err );
              }
            };
          },
          handlers = self._notificationListeners[ theNotification ].slice(); <span class="hljs-comment">// copy!</span>
        <span class="hljs-keyword">if</span> ( lastOnly &amp;&amp; handlers.length &gt; <span class="hljs-number">1</span> ) {
          handlers = [ handlers.pop() ];
        }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>attach * handlers</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">var</span> handler, push = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> listener <span class="hljs-keyword">in</span> self._notificationListeners ) {
          <span class="hljs-keyword">if</span> ( self._notificationListeners.hasOwnProperty( listener ) ) {
            handler = self._notificationListeners[ listener ];
            push = <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">if</span> ( listener.indexOf( <span class="hljs-string">"*"</span> ) &gt; -<span class="hljs-number">1</span> ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>candidate listener; see if it matches</p></div></div><div class="code"><div class="wrapper">              <span class="hljs-keyword">if</span> ( listener === <span class="hljs-string">"*"</span> ) {
                push = <span class="hljs-literal">true</span>;
              } <span class="hljs-keyword">else</span>
              <span class="hljs-keyword">if</span> ( listener.substr( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ) === <span class="hljs-string">"*"</span> &amp;&amp; listener.substr( <span class="hljs-number">1</span> ) === theNotification.substr( -<span class="hljs-number">1</span> * ( listener.length - <span class="hljs-number">1</span> ) ) ) {
                push = <span class="hljs-literal">true</span>;
              } <span class="hljs-keyword">else</span>
              <span class="hljs-keyword">if</span> ( listener.substr( -<span class="hljs-number">1</span>, <span class="hljs-number">1</span> ) === <span class="hljs-string">"*"</span> &amp;&amp; listener.substr( <span class="hljs-number">0</span>, listener.length - <span class="hljs-number">1</span> ) === theNotification.substr( <span class="hljs-number">0</span>,
                listener.length - <span class="hljs-number">1</span> ) ) {
                push = <span class="hljs-literal">true</span>;
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">var</span> starPos = listener.indexOf( <span class="hljs-string">"*"</span> );
                <span class="hljs-keyword">if</span> ( listener.substr( <span class="hljs-number">0</span>, starPos ) === theNotification.substr( <span class="hljs-number">0</span>, starPos ) &amp;&amp; listener.substr( starPos + <span class="hljs-number">1</span> ) ===
                  theNotification.substr( -<span class="hljs-number">1</span> * ( listener.length - starPos - <span class="hljs-number">1</span> ) ) ) {
                  push = <span class="hljs-literal">true</span>;
                }
              }
              <span class="hljs-keyword">if</span> ( push ) {
                handler.forEach( <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( handler )</span> </span>{
                  handlers.push( handler );
                } );
              }
            }
          }
        }
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, l = handlers.length; i &lt; l; i++ ) {
          <span class="hljs-keyword">if</span> ( async ) {
            setTimeout( notifyListener( handlers[ i ], theNotification, args ), <span class="hljs-number">0</span> );
          } <span class="hljs-keyword">else</span> {
            ( notifyListener( handlers[ i ], theNotification, args ) )();
          }
        }
      }</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'>Method notify is aliased as emit</span></p>
<p>Notifies all listeners of a particular notification that the notification
has been triggered. If the notification hasn&#39;t been registered via
<code>registerNotification</code>, an error is logged to the console, but the function
itself returns silently, so be sure to watch the console for errors.</p>
<p>Parameters:</p>
<ul>
<li><p><strong>theNotification must be a String.</strong><br/>(the notification to trigger)</p>
</li>
<li><p><strong>args is optional and must be a *.</strong><br/>(Arguments to pass to the listener; usually an array)</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">      self.notify = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( theNotification, args )</span> </span>{
        _doNotification( theNotification, {
          args: args,
          lastOnly: <span class="hljs-literal">false</span>
        } );
      };
      self.emit = self.notify;</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'>Method notifyMostRecent is aliased as emitToLast</span></p>
<p>Notifies only the most recent listener of a particular notification that
the notification has been triggered. If the notification hasn&#39;t been registered
via <code>registerNotification</code>, an error is logged to the console, but the function
itself returns silently.</p>
<p>Parameters:</p>
<ul>
<li><p><strong>theNotification must be a String.</strong><br/>(the specific notification to trigger)</p>
</li>
<li><p><strong>args is optional and must be a *.</strong><br/>(Arguments to pass to the listener; usually an array)</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">      self.notifyMostRecent = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( theNotification, args )</span> </span>{
        _doNotification( theNotification, {
          args: args,
          lastOnly: <span class="hljs-literal">true</span>
        } );
      };
      self.emitToLast = self.notifyMostRecent;</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'>Method defineProperty</span></p>
<p>Defines a property on the object. Essentially shorthand for <code>Object.defineProperty</code>. An
internal <code>_propertyName</code> variable is declared which getters and setters can access.</p>
<p>The property can be read-write, read-only, or write-only depending on the values in
<code>propertyOptions.read</code> and <code>propertyOptions.write</code>. The default is read-write.</p>
<p>Getters and setters can be provided in one of two ways: they can be automatically
discovered by following a specific naming pattern (<code>getPropertyName</code>) if
<code>propertyOptions.selfDiscover</code> is <code>true</code> (the default). They can also be explicitly
defined by setting <code>propertyOptions.get</code> and <code>propertyOptions.set</code>.</p>
<p>A property does not necessarily need a getter or setter in order to be readable or
writable. A basic pattern of setting or returning the private variable is implemented
for any property without specific getters and setters but who have indicate that the
property is readable or writable.</p>
<p>Parameters:</p>
<ul>
<li><p><strong>propertyName must be a String.</strong><br/>(the name of the property; use camelCase)</p>
</li>
<li><p><strong>propertyOptions must be an Object.</strong><br/>(the various options as described above.)</p>
</li>
</ul>
<p>Example:</p>
<pre><code>self.defineProperty ( &quot;someProperty&quot; );        // someProperty, read-write
self.defineProperty ( &quot;anotherProperty&quot;, { default: 2 } );
self.setWidth = function ( newWidth, oldWidth )
{
    self._width = newWidth;
    self.element.style.width = newWidth + &quot;px&quot;;
}
self.defineProperty ( &quot;width&quot; );   // automatically discovers setWidth as the setter.</code></pre></div></div><div class="code"><div class="wrapper">      self.defineProperty = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( propertyName, propertyOptions )</span> </span>{
        <span class="hljs-keyword">var</span> options = {
          <span class="hljs-keyword">default</span>: <span class="hljs-literal">undefined</span>,
          read: <span class="hljs-literal">true</span>,
          write: <span class="hljs-literal">true</span>,
          get: <span class="hljs-literal">null</span>,
          set: <span class="hljs-literal">null</span>,
          selfDiscover: <span class="hljs-literal">true</span>,
          prefix: <span class="hljs-string">""</span>,
          configurable: <span class="hljs-literal">true</span>,
          backingVariable: <span class="hljs-literal">true</span>
        };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>private properties are handled differently -- we want to be able to search for
_getPrivateProperty, not get_privateProperty</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">if</span> ( propertyName.substr( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ) === <span class="hljs-string">"_"</span> ) {
          options.prefix = <span class="hljs-string">"_"</span>;
        }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>allow other potential prefixes</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">if</span> ( options.prefix !== <span class="hljs-string">""</span> ) {
          <span class="hljs-keyword">if</span> ( propertyName.substr( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ) === options.prefix ) {
            propertyName = propertyName.substr( <span class="hljs-number">1</span> );
          }
        }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>merge our default options with the user options</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> property <span class="hljs-keyword">in</span> propertyOptions ) {
          <span class="hljs-keyword">if</span> ( propertyOptions.hasOwnProperty( property ) ) {
            options[ property ] = propertyOptions[ property ];
          }
        }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Capital Camel Case our function names</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">var</span> fnName = propertyName.substr( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ).toUpperCase() + propertyName.substr( <span class="hljs-number">1</span> );
        <span class="hljs-keyword">var</span> getFnName = options.prefix + <span class="hljs-string">"get"</span> + fnName,
          setFnName = options.prefix + <span class="hljs-string">"set"</span> + fnName,
          _propertyName = options.prefix + <span class="hljs-string">"_"</span> + propertyName,
          _y_getFnName = options.prefix + <span class="hljs-string">"_y_get"</span> + fnName,
          _y_setFnName = options.prefix + <span class="hljs-string">"_y_set"</span> + fnName,
          _y__getFnName = options.prefix + <span class="hljs-string">"_y__get"</span> + fnName,
          _y__setFnName = options.prefix + <span class="hljs-string">"_y__set"</span> + fnName;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>if get/set are not specified, we&#39;ll attempt to self-discover them</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">if</span> ( options.get === <span class="hljs-literal">null</span> &amp;&amp; options.selfDiscover ) {
          <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> self[ getFnName ] === <span class="hljs-string">"function"</span> ) {
            options.get = self[ getFnName ];
          }
        }
        <span class="hljs-keyword">if</span> ( options.set === <span class="hljs-literal">null</span> &amp;&amp; options.selfDiscover ) {
          <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> self[ setFnName ] === <span class="hljs-string">"function"</span> ) {
            options.set = self[ setFnName ];
          }
        }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>create the private variable</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">if</span> ( options.backingVariable ) {
          self[ _propertyName ] = options.default;
        }
        <span class="hljs-keyword">if</span> ( !options.read &amp;&amp; !options.write ) {
          <span class="hljs-keyword">return</span>; <span class="hljs-comment">// not read/write, so nothing more.</span>
        }
        <span class="hljs-keyword">var</span> defPropOptions = {
          configurable: options.configurable
        };
        <span class="hljs-keyword">if</span> ( options.read ) {
          self[ _y__getFnName ] = options.get;
          self[ _y_getFnName ] = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>if there is a getter, use it</p></div></div><div class="code"><div class="wrapper">            <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> self[ _y__getFnName ] === <span class="hljs-string">"function"</span> ) {
              <span class="hljs-keyword">return</span> self[ _y__getFnName ]( self[ _propertyName ] );
            }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>otherwise return the private variable</p></div></div><div class="code"><div class="wrapper">            <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> self[ _propertyName ];
            }
          };
          <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> self[ getFnName ] === <span class="hljs-string">"undefined"</span> ) {
            self[ getFnName ] = self[ _y_getFnName ];
          }
          defPropOptions.get = self[ _y_getFnName ];
        }
        <span class="hljs-keyword">if</span> ( options.write ) {
          self[ _y__setFnName ] = options.set;
          self[ _y_setFnName ] = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( v )</span> </span>{
            <span class="hljs-keyword">var</span> oldV = self[ _propertyName ];
            <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> self[ _y__setFnName ] === <span class="hljs-string">"function"</span> ) {
              self[ _y__setFnName ]( v, oldV );
            } <span class="hljs-keyword">else</span> {
              self[ _propertyName ] = v;
            }
            <span class="hljs-keyword">if</span> ( oldV !== v ) {
              self.notifyDataBindingElementsForKeyPath( propertyName );
            }
          };
          <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> self[ setFnName ] === <span class="hljs-string">"undefined"</span> ) {
            self[ setFnName ] = self[ _y_setFnName ];
          }
          defPropOptions.set = self[ _y_setFnName ];
        }
        <span class="hljs-built_in">Object</span>.defineProperty( self, propertyName, defPropOptions );
      };</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'>Method defineObservableProperty</span></p>
<p>Defines a custom property, which also implements a form of KVO.</p>
<p>Any options not specified are defaulted in. The default is for a property
to be observable (which fires the default propertyNameChanged notice),
read/write with no custom get/set/validate routines, and no default.</p>
<p>Observable Properties can have getters, setters, and validators. They can be
automatically discovered, assuming they follow the pattern <code>getObservablePropertyName</code>,
<code>setObservablePropertyName</code>, and <code>validateObservablePropertyName</code>. They can also be
specified explicitly by setting <code>propertyOptions.get</code>, <code>set</code>, and <code>validate</code>.</p>
<p>Properties can be read-write, read-only, or write-only. This is controlled by
<code>propertyOptions.read</code> and <code>write</code>. The default is read-write.</p>
<p>Properties can have a default value provided as well, specified by setting
<code>propertyOptions.default</code>.</p>
<p>Finally, a notification of the form <code>propertyNameChanged</code> is fired if
the value changes. If the value does <em>not</em> change, the notification is not fired.
The name of the notification is controlled by setting <code>propertyOptions.notification</code>.
If you need a notification to fire when a property is simply set (regardless of the
change in value), set <code>propertyOptions.notifyAlways</code> to <code>true</code>.</p>
<p>KVO getters, setters, and validators follow very different patterns than normal
property getters and setters.</p>
<pre><code>self.getObservableWidth = function ( returnValue ) { return returnValue; };
self.setObservableWidth = function ( newValue, oldValue ) { return newValue; };
self.validateObservableWidth = function ( testValue ) { return testValue!==10; };
self.defineObservableProperty ( &quot;width&quot; );</code></pre>
<p>Parameters:</p>
<ul>
<li><p><strong>propertyName must be a String.</strong><br/>(The specific property to define)</p>
</li>
<li><p><strong>propertyOptions must be an Object.</strong><br/>(the options for this property.)</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">      self.defineObservableProperty = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( propertyName, propertyOptions )</span> </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>set the default options and copy the specified options</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">var</span> options = {
          observable: <span class="hljs-literal">true</span>,
          notification: propertyName + <span class="hljs-string">"Changed"</span>,
          <span class="hljs-keyword">default</span>: <span class="hljs-literal">undefined</span>,
          read: <span class="hljs-literal">true</span>,
          write: <span class="hljs-literal">true</span>,
          get: <span class="hljs-literal">null</span>,
          validate: <span class="hljs-literal">null</span>,
          set: <span class="hljs-literal">null</span>,
          selfDiscover: <span class="hljs-literal">true</span>,
          notifyAlways: <span class="hljs-literal">false</span>,
          prefix: <span class="hljs-string">""</span>,
          configurable: <span class="hljs-literal">true</span>
        };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>private properties are handled differently -- we want to be able to search for
_getPrivateProperty, not get_privateProperty</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">if</span> ( propertyName.substr( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ) === <span class="hljs-string">"_"</span> ) {
          options.prefix = <span class="hljs-string">"_"</span>;
        }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>allow other potential prefixes</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">if</span> ( options.prefix !== <span class="hljs-string">""</span> ) {
          <span class="hljs-keyword">if</span> ( propertyName.substr( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ) === options.prefix ) {
            propertyName = propertyName.substr( <span class="hljs-number">1</span> );
          }
        }
        <span class="hljs-keyword">var</span> fnName = propertyName.substr( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ).toUpperCase() + propertyName.substr( <span class="hljs-number">1</span> );
        <span class="hljs-keyword">var</span> getObservableFnName = options.prefix + <span class="hljs-string">"getObservable"</span> + fnName,
          setObservableFnName = options.prefix + <span class="hljs-string">"setObservable"</span> + fnName,
          validateObservableFnName = options.prefix + <span class="hljs-string">"validateObservable"</span> + fnName,
          _y_propertyName = options.prefix + <span class="hljs-string">"_y_"</span> + propertyName,
          _y_getFnName = options.prefix + <span class="hljs-string">"_y_get"</span> + fnName,
          _y_setFnName = options.prefix + <span class="hljs-string">"_y_set"</span> + fnName,
          _y_validateFnName = options.prefix + <span class="hljs-string">"_y_validate"</span> + fnName,
          _y__getFnName = options.prefix + <span class="hljs-string">"_y__get"</span> + fnName,
          _y__setFnName = options.prefix + <span class="hljs-string">"_y__set"</span> + fnName,
          _y__validateFnName = options.prefix + <span class="hljs-string">"_y__validate"</span> + fnName;
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> property <span class="hljs-keyword">in</span> propertyOptions ) {
          <span class="hljs-keyword">if</span> ( propertyOptions.hasOwnProperty( property ) ) {
            options[ property ] = propertyOptions[ property ];
          }
        }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>if get/set are not specified, we&#39;ll attempt to self-discover them</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">if</span> ( options.get === <span class="hljs-literal">null</span> &amp;&amp; options.selfDiscover ) {
          <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> self[ getObservableFnName ] === <span class="hljs-string">"function"</span> ) {
            options.get = self[ getObservableFnName ];
          }
        }
        <span class="hljs-keyword">if</span> ( options.set === <span class="hljs-literal">null</span> &amp;&amp; options.selfDiscover ) {
          <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> self[ setObservableFnName ] === <span class="hljs-string">"function"</span> ) {
            options.set = self[ setObservableFnName ];
          }
        }
        <span class="hljs-keyword">if</span> ( options.validate === <span class="hljs-literal">null</span> &amp;&amp; options.selfDiscover ) {
          <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> self[ validateObservableFnName ] === <span class="hljs-string">"function"</span> ) {
            options.validate = self[ validateObservableFnName ];
          }
        }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>if the property is observable, register its notification</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">if</span> ( options.observable ) {
          self.registerNotification( options.notification );
        }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>create the private variable; <em>_ here to avoid self-defined </em></p></div></div><div class="code"><div class="wrapper">        self[ _y_propertyName ] = options.default;
        <span class="hljs-keyword">if</span> ( !options.read &amp;&amp; !options.write ) {
          <span class="hljs-keyword">return</span>; <span class="hljs-comment">// not read/write, so nothing more.</span>
        }
        <span class="hljs-keyword">var</span> defPropOptions = {
          configurable: <span class="hljs-literal">true</span>
        };
        <span class="hljs-keyword">if</span> ( options.read ) {
          self[ _y__getFnName ] = options.get;
          self[ _y_getFnName ] = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>if there is a getter, use it</p></div></div><div class="code"><div class="wrapper">            <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> self[ _y__getFnName ] === <span class="hljs-string">"function"</span> ) {
              <span class="hljs-keyword">return</span> self[ _y__getFnName ]( self[ _y_propertyName ] );
            }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>otherwise return the private variable</p></div></div><div class="code"><div class="wrapper">            <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> self[ _y_propertyName ];
            }
          };
          defPropOptions.get = self[ _y_getFnName ];
        }
        <span class="hljs-keyword">if</span> ( options.write ) {
          self[ _y__validateFnName ] = options.validate;
          self[ _y__setFnName ] = options.set;
          self[ _y_setFnName ] = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( v )</span> </span>{
            <span class="hljs-keyword">var</span> oldV = self[ _y_propertyName ],
              valid = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> self[ _y__validateFnName ] === <span class="hljs-string">"function"</span> ) {
              valid = self[ _y__validateFnName ]( v );
            }
            <span class="hljs-keyword">if</span> ( valid ) {
              <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> self[ _y__setFnName ] === <span class="hljs-string">"function"</span> ) {
                self[ _y_propertyName ] = self[ _y__setFnName ]( v, oldV );
              } <span class="hljs-keyword">else</span> {
                self[ _y_propertyName ] = v;
              }
              <span class="hljs-keyword">if</span> ( oldV !== v ) {
                self.notifyDataBindingElementsForKeyPath( propertyName );
              }
              <span class="hljs-keyword">if</span> ( v !== oldV || options.notifyAlways ) {
                <span class="hljs-keyword">if</span> ( options.observable ) {
                  self.notify( options.notification, {
                    <span class="hljs-string">"new"</span>: v,
                    <span class="hljs-string">"old"</span>: oldV
                  } );
                }
              }
            }
          };
          defPropOptions.set = self[ _y_setFnName ];
        }
        <span class="hljs-built_in">Object</span>.defineProperty( self, propertyName, defPropOptions );
      };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>data binding support</p></div></div><div class="code"><div class="wrapper">      self._dataBindings = [];</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'>Method dataBindOn</span></p>
<p>Configure a data binding to an HTML element (el) for
a particular property (keyPath). Returns self for chaining.</p>
<p>Parameters:</p>
<ul>
<li><p><strong>el must be a Node.</strong><br/>(the DOM element to bind to; must support the change event)</p>
</li>
<li><p><strong>keyPath must be a string.</strong><br/>(the property to observe (shallow only; doesn&#39;t follow dots.))</p>
</li>
</ul>
<p><strong>Returns a *</strong><br/>(self; chain away!)</p></div></div><div class="code"><div class="wrapper">      self.dataBindOn = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dataBindOn</span><span class="hljs-params">( el, keyPath )</span> </span>{
        <span class="hljs-keyword">if</span> ( self._dataBindings[ keyPath ] === <span class="hljs-literal">undefined</span> ) {
          self._dataBindings[ keyPath ] = [];
        }
        self._dataBindings[ keyPath ].push( el );
        el.setAttribute( <span class="hljs-string">"data-y-keyPath"</span>, keyPath );
        el.addEventListener( <span class="hljs-string">"change"</span>, self.updatePropertyForKeyPath, <span class="hljs-literal">false</span> );
        <span class="hljs-keyword">return</span> self;
      };</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'>Method dataBindOff</span></p>
<p>Turn off data binding for a particular element and
keypath.</p>
<p>Parameters:</p>
<ul>
<li><p><strong>el must be a Node.</strong><br/>(element to remove data binding from)</p>
</li>
<li><p><strong>keyPath must be a string.</strong><br/>(keypath to stop observing)</p>
</li>
</ul>
<p><strong>Returns a *</strong><br/>(self; chain away!)</p></div></div><div class="code"><div class="wrapper">      self.dataBindOff = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dataBindOff</span><span class="hljs-params">( el, keyPath )</span> </span>{
        <span class="hljs-keyword">var</span> keyPathEls = self._dataBindings[ keyPath ],
          elPos;
        <span class="hljs-keyword">if</span> ( keyPathEls !== <span class="hljs-literal">undefined</span> ) {
          elPos = keyPathEls.indexOf( el );
          <span class="hljs-keyword">if</span> ( elPos &gt; -<span class="hljs-number">1</span> ) {
            keyPathEls.splice( elPos, <span class="hljs-number">1</span> );
            el.removeAttribute( <span class="hljs-string">"data-y-keyPath"</span> );
            el.removeEventListener( <span class="hljs-string">"change"</span>, self.updatePropertyForKeyPath );
          }
        }
        <span class="hljs-keyword">return</span> self;
      };</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'>Method dataBindAllOffForKeyPath</span></p>
<p>Remove all data bindings for a given property</p>
<p>Parameters:</p>
<ul>
<li><strong>keyPath must be a String.</strong><br/>(keypath to stop observing)</li>
</ul>
<p><strong>Returns a *</strong><br/>(self; chain away)</p></div></div><div class="code"><div class="wrapper">      self.dataBindAllOffForKeyPath = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dataBindAllOffForKeyPath</span><span class="hljs-params">( keyPath )</span> </span>{
        <span class="hljs-keyword">var</span> keyPathEls = self._dataBindings[ keyPath ];
        <span class="hljs-keyword">if</span> ( keyPathEls !== <span class="hljs-literal">undefined</span> ) {
          keyPathEls.forEach( <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( el )</span> </span>{
            el.removeAttribute( <span class="hljs-string">"data-y-keyPath"</span> );
            el.removeEventListener( <span class="hljs-string">"change"</span>, self.updatePropertyForKeyPath );
          } );
          keyPathEls = [];
        }
        <span class="hljs-keyword">return</span> self;
      };</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'>Method dataBindAllOff</span></p>
<p>Remove all data bindings for this object</p>
<p><strong>Returns a *</strong><br/>(self)</p></div></div><div class="code"><div class="wrapper">      self.dataBindAllOff = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dataBindAllOff</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> keyPath <span class="hljs-keyword">in</span> self._dataBindings ) {
          <span class="hljs-keyword">if</span> ( self._dataBindings.hasOwnProperty( keyPath ) ) {
            self.dataBindAllOffForKeyPath( keyPath );
          }
        }
      };</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'>Method updatePropertyForKeyPath</span></p>
<p>Update a property on this object based on the
keyPath and value. If called as an event handler, <code>this</code> refers to the
triggering element, and keyPath is on <code>data-y-keyPath</code> attribute.</p>
<p>Parameters:</p>
<ul>
<li><p><strong>keyPath must be a String.</strong><br/>(property to set)</p>
</li>
<li><p><strong>value must be a *.</strong><br/>(value to set)</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">      self.updatePropertyForKeyPath = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updatePropertyForKeyPath</span><span class="hljs-params">( keyPath, value )</span> </span>{
        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span> !== self &amp;&amp; <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Node ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>we&#39;ve been called from an event handler</p></div></div><div class="code"><div class="wrapper">            self[ <span class="hljs-keyword">this</span>.getAttribute( <span class="hljs-string">"data-y-keyPath"</span> ) ] = <span class="hljs-keyword">this</span>.value;
            <span class="hljs-keyword">return</span>;
          }
          self[ keyPath ] = value;
        } <span class="hljs-keyword">catch</span> ( err ) {
          <span class="hljs-built_in">console</span>.log( <span class="hljs-string">"Failed to update"</span>, keyPath, <span class="hljs-string">"with"</span>, value );
        }
      };</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'>Method @notifyDataBindingElementsForKeyPath</span></p>
<p>notify all elements attached to a
key path that the source value has changed. Called by all properties created
with defineProperty and defineObservableProperty.</p>
<p>Parameters:</p>
<ul>
<li><strong>keyPath must be a String.</strong><br/>(keypath of elements to notify)</li>
</ul></div></div><div class="code"><div class="wrapper">      self.notifyDataBindingElementsForKeyPath = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">notifyDataBindingElementsForKeyPath</span><span class="hljs-params">( keyPath )</span> </span>{
        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">var</span> keyPathEls = self._dataBindings[ keyPath ],
            el;
          <span class="hljs-keyword">if</span> ( keyPathEls !== <span class="hljs-literal">undefined</span> ) {
            <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, l = keyPathEls.length; i &lt; l; i++ ) {
              el = keyPathEls[ i ];
              <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> el.value !== <span class="hljs-string">"undefined"</span> ) {
                el.value = self[ keyPath ];
              } <span class="hljs-keyword">else</span>
              <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> el.textContent !== <span class="hljs-string">"undefined"</span> ) {
                el.textContent = self[ keyPath ];
              } <span class="hljs-keyword">else</span>
              <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> el.innerText !== <span class="hljs-string">"undefined"</span> ) {
                el.innerText = self[ keyPath ];
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-built_in">console</span>.log( <span class="hljs-string">"Data bind failure; browser doesn't understand value, textContent, or innerText."</span> );
              }
            }
          }
        } <span class="hljs-keyword">catch</span> ( err ) {
          <span class="hljs-built_in">console</span>.log( <span class="hljs-string">"Failed to update elements for "</span>, keyPath );
        }
      };</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'>Method _autoInit</span></p>
<p>Auto initializes the object based on the arguments passed to the object constructor. Any object
that desires to be auto-initializable must perform the following prior to returning themselves:</p>
<pre><code>self._autoInit.apply (self, arguments);</code></pre>
<p>Each init must call the super of init, and each init must return self.</p>
<p>If the first parameter to _autoInit (and thus to the object constructor) is an object,
initWithOptions is called if it exists. Otherwise init is called with all the arguments.</p>
<p>If NO arguments are passed to the constructor (and thus to this method), then no
auto initialization is performed. If one desires an auto-init on an object that requires
no parameters, pass a dummy parameter to ensure init will be called</p>
<p><strong>Returns a *</strong></p></div></div><div class="code"><div class="wrapper">      self._autoInit = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">0</span> ) {
          <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">arguments</span>.length === <span class="hljs-number">1</span> ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>chances are this is an initWithOptions, but make sure the incoming parameter is an object</p></div></div><div class="code"><div class="wrapper">            <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">arguments</span>[ <span class="hljs-number">0</span> ] === <span class="hljs-string">"object"</span> ) {
              <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> self.initWithOptions !== <span class="hljs-string">"undefined"</span> ) {
                <span class="hljs-keyword">return</span> self.initWithOptions.apply( self, <span class="hljs-built_in">arguments</span> );
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> self.init.apply( self, <span class="hljs-built_in">arguments</span> );
              }
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> self.init.apply( self, <span class="hljs-built_in">arguments</span> );
            }
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> self.init.apply( self, <span class="hljs-built_in">arguments</span> );
          }
        }
      };</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'>Method destroy</span></p>
<p>Readies an object to be destroyed. The base object only clears the notifications and
the attached listeners.</p></div></div><div class="code"><div class="wrapper">      self.destroy = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>clear data bindings</p></div></div><div class="code"><div class="wrapper">        self.dataBindAllOff();</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>clear any listeners.</p></div></div><div class="code"><div class="wrapper">        self._notificationListeners = {};
        self._tagListeners = {};
        self._constructObjectCategories( BaseObject.ON_DESTROY_CATEGORY );</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>ready to be destroyed</p></div></div><div class="code"><div class="wrapper">      };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>self-categorize</p></div></div><div class="code"><div class="wrapper">      self._constructObjectCategories();</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>call auto init</p></div></div><div class="code"><div class="wrapper">      self._autoInit.apply( self, <span class="hljs-built_in">arguments</span> );</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>done</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">return</span> self;
    };</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'>Method promote</span></p>
<p>Promotes a non-BaseObject into a BaseObject by copying all its methods to
the new object and copying all its properties as observable properties.</p>
<p>Parameters:</p>
<ul>
<li><strong>nonBaseObject must be a *.</strong><br/>(The non-BaseObject to promote)</li>
</ul>
<p><strong>Returns a BaseObject</strong><br/>(BaseObject)</p></div></div><div class="code"><div class="wrapper">  BaseObject.promote = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">promote</span><span class="hljs-params">( nonBaseObject )</span> </span>{
    <span class="hljs-keyword">var</span> newBaseObject, theProp;
    <span class="hljs-keyword">if</span> ( nonBaseObject !== <span class="hljs-literal">undefined</span> ) {
      newBaseObject = <span class="hljs-keyword">new</span> BaseObject();
      <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> prop <span class="hljs-keyword">in</span> nonBaseObject ) {
        <span class="hljs-keyword">if</span> ( nonBaseObject.hasOwnProperty( prop ) ) {
          theProp = nonBaseObject[ prop ];
          <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> theProp === <span class="hljs-string">"function"</span> ) {
            newBaseObject[ prop ] = theProp;
          } <span class="hljs-keyword">else</span> {
            newBaseObject.defineObservableProperty( prop, {
              <span class="hljs-keyword">default</span>: theProp
            } );
          }
        }
      }
    }
    <span class="hljs-keyword">return</span> newBaseObject;
  };</div></div></div><div class="segment"><div class="comments doc-section doc-section-private"><div class="wrapper"><p><span class='doc-section-header'>Private property <em>objectCategories of type </em>{}_</span></p>
<p>Object categories. Of the form:</p>
<pre><code>{ className: [ constructor1, constructor2, ... ], ... }</code></pre>
<p>Global to the app and library. BaseObject&#39;s init() method will call each category in the class hierarchy.</p></div></div><div class="code"><div class="wrapper">  BaseObject._objectCategories = [ {}, {}, {} ];
  BaseObject.ON_CREATE_CATEGORY = <span class="hljs-number">0</span>;
  BaseObject.ON_INIT_CATEGORY = <span class="hljs-number">1</span>;
  BaseObject.ON_DESTROY_CATEGORY = <span class="hljs-number">2</span>;</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'>Method registerCategoryConstructor</span></p>
<p>Register a category constructor for a specific class. The function must take <code>self</code> as a parameter, and must
not assume the presence of any other category</p>
<p>The options parameter takes the form:</p>
<pre><code>{ class: class name to register for
  method: constructor method
  priority: ON_CREATE_CATEGORY or ON_INIT_CATEGORY
}</code></pre>
<p>Parameters:</p>
<ul>
<li><strong>options must be an Object.</strong></li>
</ul></div></div><div class="code"><div class="wrapper">  BaseObject.registerCategoryConstructor = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">registerCategoryConstructor</span><span class="hljs-params">( options )</span> </span>{
    <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> options === <span class="hljs-string">"undefined"</span> ) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>( <span class="hljs-string">"registerCategoryConstructor requires a class name and a constructor method."</span> );
    }
    <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> options.class !== <span class="hljs-string">"undefined"</span> ) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>( <span class="hljs-string">"registerCategoryConstructor requires options.class"</span> );
    }
    <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> options.method !== <span class="hljs-string">"undefined"</span> ) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>( <span class="hljs-string">"registerCategoryConstructor requires options.method"</span> );
    }
    <span class="hljs-keyword">var</span> className = options.class;
    <span class="hljs-keyword">var</span> method = options.method;
    <span class="hljs-keyword">var</span> priority = BaseObject.ON_CREATE_CATEGORY;
    <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> options.priority !== <span class="hljs-string">"undefined"</span> ) {
      priority = options.priority;
    }
    <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> BaseObject._objectCategories[ priority ][ className ] === <span class="hljs-string">"undefined"</span> ) {
      BaseObject._objectCategories[ priority ][ className ] = [];
    }
    BaseObject._objectCategories[ priority ][ className ].push( method );
  };
  BaseObject.meta = {
    version: <span class="hljs-string">"00.05.101"</span>,
    <span class="hljs-keyword">class</span>: _className,
    autoInitializable: <span class="hljs-literal">true</span>,
    categorizable: <span class="hljs-literal">true</span>
  };
  <span class="hljs-keyword">return</span> BaseObject;
} );</div></div></div></div></body></html>